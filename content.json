[{"title":"人性的弱点","date":"2019-06-24T16:00:00.000Z","path":"read/weakness-of-human-nature/","text":"交际关系？ 2019-06-25 记又是一本断断续续看完的书，最印象深刻的是多夸奖，少批评。就像经常听到的一句话“沟通 70%是情绪，30%才是事情。”","tags":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://shawdanon.github.io/tags/阅读笔记/"}]},{"title":"黑客与画家","date":"2019-06-20T16:00:00.000Z","path":"read/hackers-and-painters/","text":"一群不一样的人… 2019-06-21 记零零碎碎读完这本书，讲真没有太大的收货或者感触，对每一章的印象也不是太深，唯一的感觉就是这本书在讲极致的人做极致的事用极致的编程语言。","tags":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://shawdanon.github.io/tags/阅读笔记/"}]},{"title":"主意","date":"2019-06-12T16:00:00.000Z","path":"arrangement/my-idea/","text":"我的一些想法… 列表20170619 习惯养成类软件 日程管理类软件 过往 记账类软件 职业测评类网站 错题本类软件 书籍交换类网站 书单分享类网站 家用医疗软件 资源回收类软件 阅读相关一些阅读相关的具体想法 20170620今年开始喜欢上了阅读，再搜罗之下，先后阅读了《Web 全栈工程师的自我修养》和《腾讯传》感觉收获还是很多的。 进入正题，我所用的是多看阅读软件，阅读器的功能：能调背景、调排版（行段边距、缩进）、能更改字体样式（能把简体转化为繁体，不知道能不能把繁体转化为简体）、能调整字体大小、夜间模式、护眼模式、语言阅读、自动翻页、书签、分享、划线做笔记、转换扫描 pdf 为文字、常用设置（翻页动画、注释样式、音量键翻页、长按文字划线、启动后继续上次阅读、屏幕关闭时间、显示系统状态、显示章节名、显示时间电量）。用了有一段时间了，总结下优缺点。优点：1、能方便的转换扫描版 PDF 为文字（虽然并不完美）。2、方便的划线做笔记和导出笔记功能。3、语音阅读功能。4、电脑 WiFi 传书功能。缺点：1、图书商城内容不够多。2、没有可以定制频道。3、杂志类应该采用订阅模式阅读更好。4、没有很好的社交化、完全可以内置聊天功能、书单分享功能、读书感想功能。 20170621我想做的一个软件：以图书馆为中心，帮助大学生养成阅读习惯，了解图书的妙用。内设图书分享，社交聊天，等级（阅历）提升，评选学期网络学霸等功能","tags":[{"name":"整理","slug":"整理","permalink":"https://shawdanon.github.io/tags/整理/"}]},{"title":"富爸爸 财务自由之路","date":"2019-05-22T16:00:00.000Z","path":"read/cashflow-quadrant/","text":"ESBI，我们一生的财富… 2019-05-23 记这本书听了一遍很有感触，然后又阅读了一遍，才算有了印象。通过这本书认识到了 ESBI（Employee 雇员、SelfEmployee 自雇者、BusinessOwner 企业拥有者、Investor 投资家）四类人对金钱的看法。目前我还属于 E 象限，也会有很少部分收入来自 I 象限。大学当会长是有 S 象限的感觉，深刻体会到自己什么是都亲力亲为的性格缺陷。然后是重点讲了 I 象限的 7 种境界，0 级：没钱者（支出大于收入）；1 级：借钱者（靠消费未来的钱度日）；2 级：储蓄者（收入大于支出，会存钱到稳定机构，如银行）；3 级：‘聪明的’投资者（3A 会找人代理投资不善学习投资知识、3B 是在投资中失败后过于谨慎涨买跌卖的人、3C 是侥幸心理投资的投机者）；4 级：长期投资者（有长期计划、有明确的目标、有理财知识将钱分散投资在各种投资产品上的人）；5 级：老练的投资者（有庞大的财力和丰富的财务经验，集中式投资的人）；6 级：资本家（同时是优秀的企业家和投资者，能提前预感经济走势的人）。我目前应该处于 2 级希望成为 4 级，加油吧。","tags":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://shawdanon.github.io/tags/阅读笔记/"}]},{"title":"关于umi的半自动化脚本","date":"2019-05-18T16:00:00.000Z","path":"2019/umi-script/","text":"方便快速生成 servers/mock/models… 背景因为使用使用 umi 和 dva 所以会大量写 servers/mock/models 文件，上百个接口复制起来还是很麻烦的，所以写个脚本自动生成 servers/mock/models 文件。 思路通过 node 读取 swagger 数据，获取接口信息，再使用模板字符串拼接，然后通过 node 写入到文件中。 具体实现 为了方便二次使用，考虑设置配置文件，配置文件主要用来设置输入和输出的配置，输入是 swagger 的 url，输出是生成的文件名、文件里包含的模块和文件类型（servers/mock/models）。 同样是为了方便二次使用，需要设置 servers/mock/models 的模板字符串生成方法。 准备工作完毕（其实是写完了才分离出来的），开始写主体。首先需要请求到数据，通过 axios 请求配置文件中的 url 获取到 swagger 的数据。 接下来需要创建一个存放我们文件的文件夹，我把它创建在根目录，并且为了防止二次执行失败，需要先检查更目录是否有我们需要的文件夹。 有了存放文件的文件夹，就需要往里面写入我们需要的文件了，通过遍历配置项文件里包含的模块，可以生成我们需要的文件。 生成文件前，需要把 swagger 里的数据取出来传入之前设置的模板字符串生成方法中得到文件内容。 整个流程大概就是这样，其中又遇到接口名相同的问题，因为我的接口名取的/最后一个名字，然后做了了重名处理，在名字后面加_copy，有点不优雅，哈哈。其实也可以用接口，把/换成_不过可能会太长。还有就是我想可以做成可视化的话自己可以通过界面配置接口名。大概像 easy-mock 那样，不过不仅仅生成 mock 文件。这个项目 mock 和 models 处理的不够好还需要优化。\b 项目地址txp-swagger","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://shawdanon.github.io/tags/笔记/"}]},{"title":"记一次项目重构","date":"2019-05-08T16:00:00.000Z","path":"2019/restructure/","text":"代码惨不忍睹… 背景1、一个临时赶出来的项目。2、在都不熟悉 ant design pro 的情况下，甚至有的同学还不熟悉 react，大概经手 5 个同学一起写出来的项目。3、没有做规划直接开始写代码。4、为了方便快捷直接去除了 ant design pro 代码检查。 问题1、由于是并行开发，分工是按照模块来分的，导致前面几个模块和后面几个模块相同功能的组件会写成两份（最常见的是表格组件），当需求有修改的同时不方便统一做修改。2、代码格式没有限制，风格各异，会出现一些莫名其妙的错误，阅读成本高。3、没有约定全局样式、全局变量（版本号等）导致修改成本很高。4、权限设计过于简单，只适用于菜单。5、Tab 切换设计错误，导致从列表页到详情页后返回不能是刚才的 tab。（这里应该设计成路由）6、组件中夹杂着数据处理，逻辑不明确，导致修改成本高。 目的1、解决项目代码格式不规范问题。（需要 eslint、stylelint 工具规范检查、git 提交前验证）2、解决项目组件使用不统一问题。（同一功能组件存在两个人写的）3、解决权限管理问题（目前是菜单权限，需要控制到按钮权限）4、解决埋点问题5、优化：使用 ts 来写，利用 d.ts 来优化开发体验，提示语等。6、解决 tab 路由问题7、解决 ui 组件和逻辑分离问题 1、解决项目代码格式不规范问题。（需要 eslint、stylelint 工具规范检查、git 提交前验证）2、解决项目组件使用不统一问题。（同一功能组件存在两个人写的）3、解决权限管理问题（目前是菜单权限，需要控制到按钮权限）4、解决埋点问题5、优化：使用 ts 来写，利用 d.ts 来优化开发体验，提示语等。6、解决 tab 路由问题7、解决 ui 组件和逻辑分离问题 流程1、搭项目：基于 umi，使用 eslint、stylelint、tslint 检查，pretter 格式化，使用 ts 开发，支持 mock 数据 解决方案","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://shawdanon.github.io/tags/笔记/"}]},{"title":"reactNative","date":"2019-04-07T16:00:00.000Z","path":"2019/react-native/","text":"感受用 react-native 写 app… 环境搭建Mac 上安卓 App 开发必须安装的依赖有：Node、Watchman 和 React Native 命令行工具以及 JDK 和 Android Studio。其中大部分安装在 flutter 已有。 创建项目运行react-native init [项目名]在当前目录创建项目 运行调试在项目根目录运行react-native run-android启动项目 虚拟机双击 r 刷新 真机摇一摇手机呼出调试面板，点击Enable Hot Reloading启用热加载（Ps：需要保证电脑和手机在同一网络中）。 打包发布生成一个签名密钥在终端输入命令keytool -genkeypair -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000，根据提示输入密码、信息等，看到提示说是否正确是填入y回车，就能在当前目录生成你的签名密钥了，这个时候终端会提示让你输入命令迁移到新版本密钥，根据提示输入keytool -importkeystore -srckeystore my-release-key.keystore -destkeystore my-release-key.keystore -deststoretype pkcs12，执行完当前目录会多出一个.old 的文件（原来密钥的备份文件）。 设置 gradle 变量首先把 my-release-key.keystore 文件（你的密钥文件）放到你工程中的 android/app 文件夹下。 编辑~/.gradle/gradle.properties（全局配置，对所有项目有效）或是项目目录/android/gradle.properties（项目配置，只对所在项目有效）。如果没有 gradle.properties 文件你就自己创建一个，添加如下的代码（注意把其中的****替换为相应密码） 1234MYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=my-key-aliasMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** 把签名配置加入到项目的 gradle 配置中编辑你项目目录下的 android/app/build.gradle，添加如下的签名配置： 12345678910111213141516171819202122...android &#123; ... defaultConfig &#123; ... &#125; signingConfigs &#123; release &#123; if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125; &#125; &#125;//这个必须写在buildTypes前面要不buildTypes读取不到signingConfigs会报错 buildTypes &#123; release &#123; ... signingConfig signingConfigs.release &#125; &#125;&#125;... 生成发行 APK 包只需在终端中运行以下命令： 12cd android./gradlew assembleRelease 生成的 APK 文件位于 android/app/build/outputs/apk/release/app-release.apk，它已经可以用来发布了。 开发时的问题问题一不能写 css 文件，需要在 js 中以对象的形式来描述 css，但是没有代码提示。 解决方案：添加一个中间文件来处理。 123456789import &#123; StyleSheet as RnStyleSheet, ViewStyle, TextStyle, ImageStyle &#125; from 'react-native';type StyleProps = Partial&lt;ViewStyle | TextStyle | ImageStyle&gt;;export const StyleSheet = &#123; create(styles: &#123; [className: string]: StyleProps &#125;) &#123; return RnStyleSheet.create(styles); &#125;&#125;; 引入这个文件就有代码提示了。 12345import &#123; StyleSheet &#125; from './utils/utils.js';const styles = StyleSheet.create(&#123; ...&#125;); 问题二把组件放入目录中引入会报错The development server returned response error code: 500。 解决方案：组件放在根目录（感觉只是临时解决）。 问题三重新创建 react native 项目后，gradle 可能更新，下载很慢。解决方案：1、科学上网。2、安装你原来能够运行的 react native 版本。react-native init demo --verbose --version 0.59.4 参考资料React Native 中文网","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://shawdanon.github.io/tags/笔记/"}]},{"title":"macOS软件折腾记","date":"2019-03-13T16:00:00.000Z","path":"2019/macOS/","text":"快买 mac mini 一个月了，记录下使用体验和常用软件安装… 需要解决的功能 通过编辑器快速打开项目 软件安装zip 类型软件（双击解压，将程序拖到应用程序即可）vscode：编辑器item2：终端Gas Mask：修改 hostAndroid Studio 中文网：安卓开发KeepingYouAwake：可保证系统不自动休眠f.lux：调节显示器色温，护眼，尤其是早上起来屏幕实在是刺眼AppCleaner：卸载软件 dmg 类型软件（双击安装）Android Studio 官网|科学上网：安卓开发Lantern：科学上网Karabiner Element：键盘设置qBittorrent：下载工具，下 magnetFolx 5|科学上网：下载工具，下 httpIINA：视频播放器Parallels Desktop：Windows 虚拟机CleanMyMac X：系统管理QQ、微信、钉钉、网易云音乐、谷歌浏览器|科学上网、番茄土豆、百度网盘、迅雷、WPS Ps：科学上网下载速度慢可以复制下载链接到迅雷下载 应用商店Xcode：mac 开发Thor：一键直达Alfred：应用启动RunCat：菜单栏显示奔跑的小猫，CPU 占用率越高跑地越快 命令行软件homebrew：包管理工具git：版本管理nvm：node 版本管理工具node：前端开发 Homebrew常用命令查看帮助信息：brew help。查看版本：brew -v。更新 Homebrew：brew update。安装软件包：brew install [包名]。查询可更新的包：brew outdated。更新包：rew upgarde //更新所有包、brew upgarde [包名] //更新指定包。清理旧版本：brew cleanup //清理所有包的旧版本、brew cleanup [包名] //清理指定包的旧版本、brew cleanup -n //查看可清理的旧版本包，不执行实际操作。锁定不想更新的包：brew pin $FORMULA //锁定某个包、brew unpin $FORMULA //取消锁定。卸载安装包：brew uninstall [包名]。查看包信息：brew info [包名]。查看安装列表：brew list。查询可用包：brew search [包名]。","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://shawdanon.github.io/tags/笔记/"}]},{"title":"学习UMI","date":"2019-03-01T16:00:00.000Z","path":"2019/study-umi/","text":"第一次认真学习开源项目，看一次开源代码… 学习 UMI（一）umi@2.6.17 目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const DirectoryTree = &#123; '.github': &#123; dec: undefined, child: null &#125;, docs: &#123; dec: '说明文档', child: null &#125;, examples: &#123; dec: '例子', child: null &#125;, packages: &#123; dec: 'npm包', child: &#123; 'af-webpack': null, 'babel-preset-umi': null, 'eslint-config-umi': null, umi: null, 'umi-build-dev': null, 'umi-core': null, 'umi-library': null, 'umi-mock': null, 'umi-plugin-dll': null, 'umi-plugin-dva': null, 'umi-plugin-hd': null, 'umi-plugin-locale': null, 'umi-plugin-polyfills': null, 'umi-plugin-react': null, 'umi-plugin-routes': null, 'umi-serve': null, 'umi-test': null, 'umi-types': null, 'umi-utils': null &#125; &#125;, scripts: &#123; dec: '脚本', child: &#123; 'build.js': '构建脚本', 'publish.js': '发布脚本', 'reinstall_deps.sh': undefined, 'startDevServers.js': '启动开发服务脚本', 'test.js': '测试脚本' &#125; &#125;, website: null, '.editorconfig': 'EditorConfig配置文件|EditorConfig有助于为跨越各种编辑器和IDE的同一项目的多个开发人员维护一致的编码样式', '.eslintignore': '设置ESlint不跟踪的文件，同.gitignore一样', '.eslintrc': 'ESlint配置文件|JavaScript代码检测, JavaScript代码风格检测, JavaScript代码自动格式化', '.gitignore': '设置git不跟踪的文件', '.prettierignore': '设置Prettier不跟踪的文件，同.gitignore一样|Prettier是一个前端代码格式化工具', '.travis.yml': 'Travis配置文件|Travis CI 提供的是持续集成服务', '.yarnrc': 'yarn配置文件，配置了使用官方镜像源', 'jasmine.js': ' Jasmine配置文件|Jasmine是一个测试框架，配置了超时时间', 'jest.config.js': 'jest配置文件', 'lerna.json': 'lerna配置文件|Lerna 是一个用来优化托管在git、npm上的多package代码库的工作流的一个管理工具。', 'package.json': null, '（废弃集成到了umi-tools中）rollup.config.js': 'rollup配置文件|rollup是一款打包工具', 'tsconfig.json': 'TypeScript配置文件|指定ts编译的一些参数信息'&#125;; 整个目录看下来光工具和包很多都没接触过，代码检查有用过 eslint，项目落地还是不多，这个月看来要恶补一番前端开发规范啊。 一级目录package.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; \"private\": true, //私有，防止npm意外发布 \"scripts\": &#123; \"bootstrap\": \"lerna bootstrap\", \"build\": \"./scripts/build.js\", \"changelog\": \"lerna-changelog\", \"chore:update-deps\": \"./scripts/update_deps.sh\", \"test\": \"node scripts/test.js\", \"test:coverage\": \"./packages/umi-test/bin/umi-test.js --coverage\", \"debug\": \"./packages/umi-test/bin/umi-test.js\", \"coveralls\": \"cat ./coverage/lcov.info | coveralls\", \"lint\": \"eslint --ext .js packages\", \"precommit\": \"lint-staged\", \"doc:dev\": \"./website/node_modules/.bin/vuepress dev ./docs\", \"doc:deploy\": \"rm -rf ./website/yarn.lock &amp;&amp; cd ./website &amp;&amp; npm run deploy &amp;&amp; cd -\", \"publish\": \"./scripts/publish.js\", \"ui:dev\": \"APP_ROOT=packages/umi-build-dev/src/plugins/commands/ui ./packages/umi/bin/umi.js dev\", \"ui:build\": \"APP_ROOT=packages/umi-build-dev/src/plugins/commands/ui ./packages/umi/bin/umi.js build\" &#125;, //脚本 \"lint-staged\": &#123; \"*.(t|j)s\": [\"prettier --trailing-comma all --single-quote --write\", \"git add\"] &#125;, \"devDependencies\": &#123; \"@types/jest\": \"^24.0.5\", //Jest的TypeScript定义 \"babel-eslint\": \"10.0.1\", //eslint的解析器，一个对Babel解析器的包装，使其能够与 ESLint 兼容。 \"chokidar\": \"2.0.4\", //监听文件变化 \"coveralls\": \"3.0.2\", //代码覆盖率 \"dva\": \"2.4.1\", //数据流管理 \"eslint\": \"5.10.0\", //可组装的JavaScript和JSX检查工具 \"eslint-config-airbnb\": \"17.1.0\", //airbnb的eslint规范 \"eslint-plugin-import\": \"2.14.0\", //导入导出文件检查 \"eslint-plugin-jsx-a11y\": \"6.1.2\", //用于JSX元素的可访问性规则的静态AST检查器 \"eslint-plugin-react\": \"7.11.1\", //react检查器扩展插件 \"form-data\": \"^2.3.3\", //用于创建可读\"multipart/form-data\"流的库。可用于将表单和文件上载提交到其他Web应用程序。 \"got\": \"9.3.2\", //简化的HTTP请求 \"husky\": \"1.2.0\", //git commit、git push前检查代码 \"lerna\": \"3.6.0\", //包管理工具 \"lerna-changelog\": \"0.8.2\", //为 Lerna repo 生成变更日志 \"lint-staged\": \"8.1.0\", //提交前运行阻止提交不合规范代码 \"mkdirp\": \"^0.5.1\", //递归创建目录及其子目录,代替mkdir -p \"prettier\": \"1.15.3\", //格式化 \"puppeteer\": \"1.11.0\", //Puppeteer是一个Node库，它提供了一个高级API来控制DevTools协议上的 Chrome或Chromium 。 \"react-router-dom\": \"4.3.1\", //react路由 \"react-test-renderer\": \"16.6.3\", //单元测试 \"serve-handler\": \"5.0.8\", //此包代表正在运行的服务和静态部署的核心。 \"serve-static\": \"^1.13.2\", //这是一个通过npm注册表提供的Node.js模块。 \"shelljs\": \"0.8.3\", //ShellJS是Node.js API之上的Unix shell命令的可移植（Windows / Linux / OS X）实现。 \"test-build-result\": \"^1.1.2\", //测试构建结果 \"umi-tools\": \"^0.4.0\" //用于构建umi的工具。 &#125;&#125; Lerna从目录架构来看，首先要学的是多包管理与发布。通过多包管理可以把作者多个包放在一起用一个仓库储存来维护。（PS：npm 包上传后不能删除，强迫症患者需要慎重取名） 使用说明： 全局安装 lerna 包npm install lerna -g。 在 github 创建一个仓库，并拉下来备用。 在该仓库根目录初始化 lernalerna init。初始化成功会多出 3 个文件： packages(目录，用于存放包)、 lerna.json(配置文件，用于 lerna 配置)、package.json(工程描述文件) 修改 lerna.json 文件中的 version 值，默认是&quot;version&quot;: &quot;0.0.0&quot;（使用这个模式，在发布包的时候所有的包都会发布，并使用 lerna.json 中设置的版本号），修改为&quot;version&quot;: &quot;independent&quot;（使用这个模式，可以单独发布包更新，可喜的是发布包可以自动生成版本号供你选择）。 在 packages 目录中创建自己的包，在当前包目录执行lerna publish来发布包。（发布包需要确定 npm 镜像源是https://registry.npmjs.org/，发布包前需要登录 npm，使用npm login登录。） 常用命令： lerna init：创建新的 lerna repo 或将现有 repo 升级到当前版本的 Lerna。 lerna bootstrap：将把 repo 中的依赖关系链接在一起。 lerna publish：将帮助发布任何更新的包。 基本使用会了，让我们回到 umi 中看看lerna.json都配置了些什么。 1234567891011121314151617181920&#123; \"changelog\": &#123; \"labels\": &#123; \"pr: enhancement\": \":rocket: Enhancement\", //增强 \"pr: bug\": \":bug: Bug Fix\", //错误修复 \"pr: documentation\": \":book: Documentation\", //文档 \"pr: dependency\": \":deciduous_tree: Dependency\" &#125;, //GitHub PR标签映射到changelog部分标头 \"repo\": \"umijs/umi\", //你在GitHub上的“组织/回购”（从package.json文件中自动推断） \"cacheDir\": \".changelog\" //GitHub API响应缓存的路径以避免限制（例如.changelog） &#125;, \"packages\": [\"packages/*\"], //包位置 \"command\": &#123; \"version\": &#123; \"exact\": true &#125; &#125;, \"npmClient\": \"yarn\", //一个选项，用于指定运行命令的特定客户端（也可以基于每个命令指定）。更改为\"yarn\"使用yarn运行所有命令。默认为“npm” \"version\": \"independent\" //存储库的当前版本，使用独立模式&#125; TravisTravis 是一款持续集成工具。那么持续集成是什么呢？ 持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 如何使用 Travis？ 在 Travis 官网使用 github 账号注册登录，会看到你仓库所有的项目。 打开你想持续集成的项目开关。 在该项目创建.travis.yml文件，文件内容至少包含language: node_js和node_js: - &#39;6&#39; 提交代码，Travis 就会自动进行构建了。 构建成功会在 Travis 中显示 build pass 的按钮，点击按钮会有个弹窗，选择 markdown 格式复制链接到项目 readme 中就拥有构建徽章了。 大概了解了下 Travis，接下来看看 umi 中.travis.yml文件写了些什么。 1234567891011121314151617181920# 指定语言language: node_js# 指定版本node_js: - '8' - '10'# 脚本阶段之前before_script: - npm run build - npm run bootstrap# 构建成功after_success: - npm run coveralls# 缓存Node.js模块cache: directories: - node_modulesgit: depth: 5 Jest1234567891011121314151617181920212223242526module.exports = &#123; testPathIgnorePatterns: [ '/node_modules/', '/examples/', '/lib/', '/packages/umi/src/scripts/test.js', '/packages/umi/src/test.js', '/packages/umi-build-dev/src/fixtures', '/packages/umi-build-dev/src/routes/fixtures', '/packages/umi-plugin-dva/src/fixtures', '/packages/umi-utils/src/fixtures', '/packages/umi-library/src/fixtures', '/packages/umi/test/fixtures' ], //排除测试的文件 setupFilesAfterEnv: ['./jasmine.js'], //在每次测试之前运行一些代码以配置或设置测试框架的模块的路径列表。 collectCoverageFrom: ['packages/**/src/**/*.&#123;js,jsx&#125;'], //应收集覆盖率信息的一组文件。 coveragePathIgnorePatterns: [ '/packages/umi-plugin-dva/src/fixtures', '/packages/umi-build-dev/src/fixtures', '/packages/umi-build-dev/src/routes/fixtures', '/packages/umi-build-dev/src/plugins/commands/generate/generators', '/packages/umi-library/src/fixtures', '/packages/umi-utils/src/fixtures', '/packages/umi/test/fixtures' ] //覆盖率排除的文件。&#125;; EditorConfig123456789101112131415161718192021222324# http://editorconfig.org#应在任何部分之外的文件顶部指定的特殊属性。设置为true以停止.editorconfig在当前文件上搜索文件。root = true#所有文件配置[*]#设置缩进风格为空格indent_style = space#缩进大小（单行间距）indent_size = 2#行结束文件格式（Unix，DOS，Mac）换行符end_of_line = lf#文件字符编码charset = utf-8#设置为true以删除换行符前面的任何空白字符，并设置为false以确保不会。trim_trailing_whitespace = true#设置为真以换行符节能时，确保文件最终假，以确保它不会。insert_final_newline = true[*.md]trim_trailing_whitespace = false[Makefile]indent_style = tab ESLint1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#123; \"parser\": \"babel-eslint\", //指定解析器 \"extends\": \"airbnb\", //使用airbnb配置扩展 \"env\": &#123; \"browser\": true, \"jest\": true &#125;, //指定配置文件中的环境 \"rules\": &#123; \"jsx-a11y/href-no-hash\": [0], \"jsx-a11y/click-events-have-key-events\": [0], \"jsx-a11y/anchor-is-valid\": [ \"error\", &#123; \"components\": [\"Link\"], \"specialLink\": [\"to\"] &#125; ], \"generator-star-spacing\": [0], \"consistent-return\": [0], \"react/react-in-jsx-scope\": [0], \"react/forbid-prop-types\": [0], \"react/jsx-filename-extension\": [1, &#123; \"extensions\": [\".js\"] &#125;], \"global-require\": [1], \"import/prefer-default-export\": [0], \"react/jsx-no-bind\": [0], \"react/prop-types\": [0], \"react/prefer-stateless-function\": [0], \"no-else-return\": [0], \"no-restricted-syntax\": [0], \"import/no-extraneous-dependencies\": [0], \"no-use-before-define\": [0], \"jsx-a11y/no-static-element-interactions\": [0], \"no-nested-ternary\": [0], \"arrow-body-style\": [0], \"import/extensions\": [0], \"no-bitwise\": [0], \"no-cond-assign\": [0], \"import/no-unresolved\": [0], \"require-yield\": [1], \"no-param-reassign\": [0], \"no-shadow\": [0], \"no-underscore-dangle\": [0], \"spaced-comment\": [0], \"indent\": [0], \"quotes\": [0], \"func-names\": [0], \"arrow-parens\": [0], \"space-before-function-paren\": [0], \"no-useless-escape\": [0], \"object-curly-newline\": [0], \"function-paren-newline\": [0], \"class-methods-use-this\": [0], \"no-new\": [0], \"import/newline-after-import\": [0], \"no-console\": [0] &#125;, //规则覆盖 \"parserOptions\": &#123; \"ecmaFeatures\": &#123; \"experimentalObjectRestSpread\": true &#125; //启用对实验对象休息/传播属性的支持,弃用 &#125; //指定解析器选项&#125; Typescript12345678&#123; \"compilerOptions\": &#123; \"target\": \"esnext\",//指定ECMAScript的目标版本,\"ESNext\"目标是最新支持的ES提议功能。 \"moduleResolution\": \"node\",//确定如何解决模块。 \"jsx\": \"preserve\",//在.tsx文件中支持JSX \"esModuleInterop\": true//发布__importStar和生成器__importDefault兼容性，用于运行时babel生态系统兼容性，并支持--allowSyntheticDefaultImports类型系统兼容性。 &#125;&#125; scripts 文件夹build.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*child_process 模块提供了以与 popen(3) 类似但不相同的方式衍生子进程的功能。child_process.fork():衍生一个新的 Node.js 进程，并通过建立 IPC 通信通道来调用指定的模块，该通道允许在父进程与子进程之间发送消息。*/const &#123; fork &#125; = require('child_process');/*path 模块提供用于处理文件路径和目录路径的实用工具。*/const &#123; join &#125; = require('path');function runUmiTools(...args) &#123; console.log(['&gt;&gt; umi-tools', ...args].join(' ')); /* child_process.fork(modulePath[, args][, options]) modulePath &lt;string&gt; 要在子进程中运行的模块。 args &lt;string[]&gt; 字符串参数的列表。 options &lt;Object&gt; stdio &lt;Array&gt; | &lt;string&gt; 参阅 child_process.spawn() 的 stdio。当提供此选项时，则它覆盖 silent 选项。如果使用了数组变量，则它必须包含一个值为 'ipc' 的元素，否则会抛出错误。例如 [0, 1, 2, 'ipc']。 cwd &lt;string&gt; 子进程的当前工作目录。 返回: &lt;ChildProcess&gt; */ /* path.join([...paths]) ...paths &lt;string&gt; 路径片段的序列。 返回: &lt;string&gt; path.join() 方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。 零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 '.'，表示当前工作目录。 */ /* process.cwd() 方法返回 Node.js 进程的当前工作目录。 */ return fork(join(process.cwd(), 'node_modules/.bin/umi-tools'), [...args].concat(process.argv.slice(2)), &#123; stdio: 'inherit', cwd: process.cwd() &#125;);&#125;const cp = runUmiTools('build');/*'error' 事件err &lt;Error&gt; 错误对象。当出现以下情况时触发 'error' 事件：1.无法衍生进程；2.无法杀死进程；3.向子进程发送信息失败。发生错误后，'exit' 事件可能会也可能不会触发。如果同时监听了 'exit' 和 'error' 事件，可能会多次调用处理函数。*/cp.on('error', err =&gt; &#123; console.log(err);&#125;);/*'message' 事件 message &lt;Object&gt; JSON 对象或原始值。 sendHandle &lt;Handle&gt; net.Socket 或 net.Server 对象，或 undefined。当子进程使用 process.send() 发送消息时触发。消息通过序列化和解析传递，收到的消息可能跟发送的不完全一样。*/cp.on('message', message =&gt; &#123; if (message === 'BUILD_COMPLETE') &#123; runUmiTools('rollup', '-g', 'dva:dva,antd:antd'); &#125; //构建完成打包&#125;); publish.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*ShellJS是 Node.js API之上的Unix shell 命令的可移植（Windows / Linux / OS X）实现。您可以使用它来消除shell脚本对Unix的依赖性，同时仍保留其熟悉且功能强大的命令。您也可以在全局安装它，这样您就可以从Node项目外部运行它- 告别那些粗糙的Bash脚本！*/const shell = require('shelljs');const &#123; join &#125; = require('path');const &#123; fork &#125; = require('child_process');/*shell.exec(command [, options] [, callback])执行命令options： async：异步执行。如果提供了回调，则true无论传递的值如何（默认值:)，都将设置为回调 false。 silent：不要将程序输出回显到控制台（默认值:) false。 encoding：要使用的字符编码。影响返回到stdout和stderr的值，以及未处于静默模式时写入stdout和stderr的值（默认值:) 'utf8'。以及Node.js可用的任何选项 child_process.exec()除非另有说明，否则command同步执行给定的给定。在同步模式下，这将返回ShellString。否则，这将返回子进程对象，并callback接收参数(code, stdout, stderr)。*/if (!shell.exec('npm config get registry').stdout.includes('https://registry.npmjs.org/')) &#123; console.error('Failed: set npm registry to https://registry.npmjs.org/ first'); process.exit(1); //退出进程&#125; //判断当前npm镜像源是否为npm官方源，不是则失败提示请设置镜像源const cwd = process.cwd();const ret = shell.exec('./node_modules/.bin/lerna updated').stdout; //运行lerna updated时的输出const updatedRepos = ret .split('\\n') .map(line =&gt; line.replace('- ', '')) .filter(line =&gt; line !== ''); //筛选出需要更新的仓库if (updatedRepos.length === 0) &#123; console.log('No package is updated.'); process.exit(0);&#125; //没有需要更新仓库的情况const &#123; code: buildCode &#125; = shell.exec('npm run build'); //执行构建if (buildCode === 1) &#123; console.error('Failed: npm run build'); process.exit(1);&#125; //构建失败情况const &#123; code: uiBuildCode &#125; = shell.exec('npm run ui:build'); //执行ui构建if (uiBuildCode === 1) &#123; console.error('Failed: npm run ui:build'); process.exit(1);&#125; //ui构建失败情况const cp = fork(join(process.cwd(), 'node_modules/.bin/lerna'), ['version'].concat(process.argv.slice(2)), &#123; stdio: 'inherit', cwd: process.cwd()&#125;);cp.on('error', err =&gt; &#123; console.log(err);&#125;);/*code &lt;number&gt; 子进程的退出码。signal &lt;string&gt; 终止子进程的信号。当子进程的 stdio 流被关闭时触发。 与 'exit' 事件的区别是，多个进程可能共享同一 stdio 流。*/cp.on('close', code =&gt; &#123; console.log('code', code); if (code === 1) &#123; console.error('Failed: lerna publish'); process.exit(1); &#125; publishToNpm();&#125;);function publishToNpm() &#123; console.log(`repos to publish: $&#123;updatedRepos.join(', ')&#125;`); updatedRepos.forEach(repo =&gt; &#123; shell.cd(join(cwd, 'packages', repo)); const &#123; version &#125; = require(join(cwd, 'packages', repo, 'package.json')); if (version.includes('-rc.') || version.includes('-beta.') || version.includes('-alpha.')) &#123; console.log(`[$&#123;repo&#125;] npm publish --tag next`); shell.exec(`npm publish --tag next`); &#125; else &#123; console.log(`[$&#123;repo&#125;] npm publish`); shell.exec(`npm publish`); &#125; //版本包含-rc.-beta.-alpha.字眼更新标签，否则直接发布 &#125;);&#125; startDevServers.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const &#123; fork &#125; = require('child_process');const &#123; join, dirname &#125; = require('path');const DEV_SCRIPT = join(__dirname, '../packages/umi/bin/umi.js');function startDevServer(opts = &#123;&#125;) &#123; const &#123; port, cwd &#125; = opts; return new Promise(resolve =&gt; &#123; const child = fork(DEV_SCRIPT, ['dev', '--port', port, '--cwd', cwd], &#123; env: &#123; ...process.env, CLEAR_CONSOLE: 'none', BROWSER: 'none', UMI_DIR: dirname(require.resolve('../packages/umi/package')) &#125; &#125;); child.on('message', args =&gt; &#123; if (args.type === 'DONE') &#123; resolve(child); &#125; &#125;); &#125;);&#125;function start() &#123; const devServers = [ [12341, '../packages/umi/test/fixtures/e2e/normal'], [12342, '../packages/umi/test/fixtures/e2e/hashHistory'], [12351, '../packages/umi-plugin-react/test/normal'], [12352, '../packages/umi-plugin-react/test/with-dva'], [12353, '../packages/umi-plugin-react/test/pwa'] ]; return Promise.all( devServers.map(([port, cwd]) =&gt; &#123; return startDevServer(&#123; port, cwd: join(__dirname, cwd) &#125;); &#125;) );&#125;module.exports = start;if (require.main === module) &#123; start() .then(() =&gt; &#123; console.log('All dev servers are started.'); &#125;) .catch(e =&gt; &#123; console.log(e); &#125;);&#125; test.js12345678910111213141516171819/*child_process.spawn() 方法异步地衍生子进程，且不阻塞 Node.js 事件循环。 child_process.spawnSync() 方法则以同步的方式提供等效功能，但会阻止事件循环直到衍生的进程退出或终止。*/const &#123; spawn &#125; = require('child_process');const startDevServers = require('./startDevServers');startDevServers() .then(devServers =&gt; &#123; const testCmd = spawn(/^win/.test(process.platform) ? 'npm.cmd' : 'npm', ['run', 'test:coverage'], &#123; stdio: 'inherit' &#125;); testCmd.on('exit', code =&gt; &#123; devServers.forEach(devServer =&gt; devServer &amp;&amp; devServer.kill('SIGINT')); process.exit(code); &#125;); &#125;) .catch(e =&gt; &#123; console.log(e); &#125;); 总结2019/3/31通过了解 umi 的源码知道了很多有意思的东西：npm 包发布、通过 lerna 来管理包、使用 Travis 持续集成项目、EditorConfig 来保证不同编辑器风格一致、ESLint 保证代码风格一致、Jest 测试保证代码可靠性、lint-staged 和 husky 阻止代码提交（最开始在 ant design pro 有遇到），shelljs 执行脚本命令。 demo 地址准备用来存些常用库的仓库 参考一创建并发布一个小而美的 npm 包，没你想的那么难！lerna 管理前端 packages 的最佳实践lerna 文档lerna-changelog 文档前端开源项目持续集成三剑客editorconfigeslintNode.js 中文网shelljs 学习 UMI（二）umi@2.6.17正式开始看源码了 packages/umi重要的packages/umi/package.json先来看看 package.json 文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123; \"name\": \"umi\", \"version\": \"2.6.16\", \"description\": \"Pluggable enterprise-level react application framework.\", \"dependencies\": &#123; \"@babel/core\": \"7.2.2\", //babel核心包 \"@babel/runtime\": \"7.3.0\", //一个包含Babel模块化运行时助手和一个版本的库 \"@types/react\": \"16.x\", //react \"@types/react-router-dom\": \"4.x\", //react路由 \"babel-preset-umi\": \"1.4.1\", //云谦的babel预设 \"debug\": \"4.1.0\", //一个微小的JavaScript调试工具，以Node.js核心的调试技术为模型。适用于Node.js和Web浏览器。 \"dotenv\": \"6.2.0\", //Dotenv是一个零依赖模块，可以将.env文件中的环境变量加载到process.env。在与代码分开的环境中存储配置基于The Twelve-Factor App方法。 \"is-windows\": \"1.0.2\", //如果平台是windows，则返回true。UMD模块，适用于node.js，commonjs，浏览器，AMD，电子等。 \"lodash\": \"4.17.11\", //一个现代JavaScript实用程序库，提供模块化，性能和附加功能。深拷贝用过 \"react-loadable\": \"5.5.0\", //用于加载具有动态导入的组件的更高阶组件。 \"resolve-cwd\": \"2.0.0\", //解析模块的路径，require.resolve()但是从当前工作目录中解析 \"semver\": \"5.6.0\", //节点的semver解析器，语义化版本 \"signale\": \"1.3.0\", //可记录和可配置到核心，signale可用于记录目的，状态报告，以及处理其他节点模块和应用程序的输出呈现过程。 \"umi-build-dev\": \"1.8.3\", //未有readme文件具体功能暂时不知 \"umi-utils\": \"1.4.1\", //工具类 \"update-notifier\": \"2.5.0\", //更新CLI应用程序的通知 \"yargs-parser\": \"13.0.0\" //Yargs通过解析参数和生成优雅的用户界面来帮助您构建交互式命令行工具。 &#125;, //依赖包 \"module\": \"index.js\", \"sideEffects\": [\"./lib/renderRoutes.js\"], \"bin\": &#123; \"umi\": \"./bin/umi.js\" &#125;, //很多软件包都有一个或多个可以安装到PATH中的可执行文件。 \"license\": \"MIT\", \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/umijs/umi/tree/master/packages/umi\" &#125;, \"homepage\": \"https://github.com/umijs/umi/tree/master/packages/umi\", \"authors\": [\"chencheng &lt;sorrycc@gmail.com&gt; (https://github.com/sorrycc)\"], \"bugs\": &#123; \"url\": \"https://github.com/umijs/umi/issues\" &#125;, \"files\": [ \"lib\", \"src\", \"bin\", \"index.js\", \"index.d.ts\", \"babel.js\", \"dynamic.d.ts\", \"link.d.ts\", \"navlink.d.ts\", \"prompt.d.ts\", \"redirect.d.ts\", \"router.d.ts\", \"withRouter.d.ts\", \"routerTypes.d.ts\" ], //可选files字段是一个文件模式数组，描述了将软件包作为依赖项安装时要包含的条目。 \"umiTools\": &#123; \"browserFiles\": [ \"src/createHistory.js\", \"src/dynamic.js\", \"src/link.js\", \"src/navlink.js\", \"src/prompt.js\", \"src/redirect.js\", \"src/renderRoutes.js\", \"src/Route.js\", \"src/router.js\", \"src/runtimePlugin.js\", \"src/utils.js\", \"src/withRouter.js\" ] &#125;&#125; 提供接口相关的文件packages/umi/index.js1234567export &#123; default as Link &#125; from './lib/link';export &#123; default as NavLink &#125; from './lib/navlink';export &#123; default as Redirect &#125; from './lib/redirect';export &#123; default as dynamic &#125; from './lib/dynamic';export &#123; default as router &#125; from './lib/router';export &#123; default as withRouter &#125; from './lib/withRouter';export &#123; default as Route &#125; from './lib/Route'; umi 输出的 api 对应官方文档。 packages/umi/link.jslink 组件直接使用 react-router 的 link 组件 12import &#123; Link &#125; from 'react-router-dom';export default Link; packages/umi/NavLink.jsNavLink 组件直接使用 react-router 的 NavLink 组件 12import &#123; NavLink &#125; from 'react-router-dom';export default NavLink; packages/umi/Redirect.jsRedirect 组件直接使用 react-router 的 Redirect 组件 12import &#123; Redirect &#125; from 'react-router-dom';export default Redirect; packages/umi/router.jsjs 路由操作文件 1234567891011121314151617181920212223242526272829/* global window */export function push(...args) &#123; window.g_history.push(...args);&#125;export function replace(...args) &#123; window.g_history.replace(...args);&#125;export function go(...args) &#123; window.g_history.go(...args);&#125;export function goBack(...args) &#123; window.g_history.goBack(...args);&#125;export function goForward(...args) &#123; window.g_history.goForward(...args);&#125;export default &#123; push, replace, go, goBack, goForward&#125;; packages/umi/withRouter.jswithRouter 组件直接使用 react-router 的 withRouter 组件 12import &#123; withRouter &#125; from 'react-router-dom';export default withRouter; packages/umi/Route.jsRoute 组件直接使用 react-router 的 Route 组件 12import &#123; Route &#125; from 'react-router-dom';export default Route; packages/umi/dynamic.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React from 'react';import Loadable from 'react-loadable';// Thanks to next.js// ref: https://github.com/zeit/next.js/blob/canary/lib/dynamic.jsexport default function(dynamicOptions, options) &#123; let loadableFn = Loadable; let loadableOptions = &#123; loading: (&#123; error, isLoading &#125;) =&gt; &#123; if (process.env.NODE_ENV === 'development') &#123; if (isLoading) &#123; return &lt;p&gt;loading...&lt;/p&gt;; &#125; if (error) &#123; return ( &lt;p&gt; &#123;error.message&#125; &lt;br /&gt; &#123;error.stack&#125; &lt;/p&gt; ); &#125; &#125; return &lt;p&gt;loading...&lt;/p&gt;; &#125; &#125;; // Support for direct import(), // eg: dynamic(import('../hello-world')) if (typeof dynamicOptions.then === 'function') &#123; loadableOptions.loader = () =&gt; dynamicOptions; // Support for having first argument being options, // eg: dynamic(&#123;loader: import('../hello-world')&#125;) &#125; else if (typeof dynamicOptions === 'object') &#123; loadableOptions = &#123; ...loadableOptions, ...dynamicOptions &#125;; &#125; // Support for passing options, // eg: dynamic(import('../hello-world'), &#123;loading: () =&gt; &lt;p&gt;Loading something&lt;/p&gt;&#125;) loadableOptions = &#123; ...loadableOptions, ...options &#125;; // Support for `render` when using a mapping, // eg: `dynamic(&#123; modules: () =&gt; &#123;return &#123;HelloWorld: import('../hello-world')&#125;, render(props, loaded) &#123;&#125; &#125; &#125;) if (dynamicOptions.render) &#123; loadableOptions.render = (loaded, props) =&gt; dynamicOptions.render(props, loaded); &#125; // Support for `modules` when using a mapping, // eg: `dynamic(&#123; modules: () =&gt; &#123;return &#123;HelloWorld: import('../hello-world')&#125;, render(props, loaded) &#123;&#125; &#125; &#125;) if (dynamicOptions.modules) &#123; loadableFn = Loadable.Map; const loadModules = &#123;&#125;; const modules = dynamicOptions.modules(); Object.keys(modules).forEach(key =&gt; &#123; const value = modules[key]; if (typeof value.then === 'function') &#123; loadModules[key] = () =&gt; value.then(mod =&gt; mod.default || mod); return; &#125; loadModules[key] = value; &#125;); loadableOptions.loader = loadModules; &#125; return loadableFn(loadableOptions);&#125; 命令相关的文件packages/umi/bin/umi.jsumi 命令的入口文件，umi [option]就会执行这个文件了。 12345678910111213#!/usr/bin/env nodeconst resolveCwd = require('resolve-cwd');const localCLI = resolveCwd.silent('umi/bin/umi'); //获取模块路径，测试结果为nullif (localCLI &amp;&amp; localCLI !== __filename) &#123; const debug = require('debug')('umi'); debug('Using local install of umi'); require(localCLI);&#125; else &#123; require('../lib/cli');&#125; //执行cli packages/umi/src/cli.js从入口文件来到具体命令处理的文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; dirname &#125; from 'path';import yParser from 'yargs-parser';import signale from 'signale';import semver from 'semver';import buildDevOpts from './buildDevOpts';//process.argv属性返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数。const script = process.argv[2]; //获取第一个可选参数（数组前两个是路径）const args = yParser(process.argv.slice(3)); //获取第一个可选参数之后的参数，转换成对象。如：umi dev -a -name=1，args为&#123;_:[],a:true,name:1&#125;// Node版本检查const nodeVersion = process.versions.node; //node版本号if (semver.satisfies(nodeVersion, '&lt;6.5')) &#123; signale.error(`Node version must &gt;= 6.5, but got $&#123;nodeVersion&#125;`); process.exit(1);&#125; //版本小于6.5提示node版本大于等于6.5并退出程序// 进程退出（defer: true ）时通知更新const updater = require('update-notifier');const pkg = require('../package.json');updater(&#123; pkg &#125;).notify(&#123; defer: true &#125;);process.env.UMI_DIR = dirname(require.resolve('../package')); //当前包根目录路径process.env.UMI_VERSION = pkg.version; //当前包版本const aliasMap = &#123; '-v': 'version', '--version': 'version', '-h': 'help', '--help': 'help'&#125;; //扩展命令//如果umi后面有build、dev、test、inspect参数就执行对应scripts文件中的脚本，否则引入umi-build-dev执行switch (script) &#123; case 'build': case 'dev': case 'test': case 'inspect': require(`./scripts/$&#123;script&#125;`); break; default: &#123; const Service = require('umi-build-dev/lib/Service').default; new Service(buildDevOpts(args)).run(aliasMap[script] || script, args); break; &#125;&#125; packages/umi/src/buildDevOpts.js加载 env 环境并对应平台返回 app 目录路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//path.join() 方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。//path.isAbsolute() 方法检测 path 是否为绝对路径。import &#123; join, isAbsolute &#125; from 'path';//fs.readFileSync() 同步地读取文件的全部内容。//fs.existsSync() 通过检查文件系统来测试给定的路径是否存在。import &#123; readFileSync, existsSync &#125; from 'fs';//isWindows 判断是否为Windows平台import isWindows from 'is-windows';//winPath 将Windows反斜杠路径转换为斜杠路径：foo\\\\bar➔foo/barimport &#123; winPath &#125; from 'umi-utils';import &#123; parse &#125; from 'dotenv';export default function(opts = &#123;&#125;) &#123; loadDotEnv(); //加载env环境 let cwd = opts.cwd || process.env.APP_ROOT; //得到将传入路径或者环境设置路径 if (cwd) &#123; if (!isAbsolute(cwd)) &#123; cwd = join(process.cwd(), cwd); &#125; //cwd不是绝对路径转换为绝对路径 cwd = winPath(cwd); //将Windows反斜杠路径转换为斜杠路径：foo\\\\bar➔foo/ba // 原因：webpack 的 include 规则得是 \\ 才能判断出是绝对路径 if (isWindows()) &#123; cwd = cwd.replace(/\\//g, '\\\\'); &#125; //如果是Windows平台将/替换为\\\\ foo/bar➔foo\\\\bar //感觉上面两步怎么不弄成一步来呢 &#125; return &#123; cwd &#125;;&#125;function loadDotEnv() &#123; //process.cwd() 方法返回 Node.js 进程的当前工作目录。 const baseEnvPath = join(process.cwd(), '.env'); //获取当前进程目录下.env路径 const localEnvPath = `$&#123;baseEnvPath&#125;.local`; //获取当前进程目录下.env.local路径 const loadEnv = envPath =&gt; &#123; //判断路径是否存在env的文件，存在就读取文件遍历设置env if (existsSync(envPath)) &#123; const parsed = parse(readFileSync(envPath, 'utf-8')); Object.keys(parsed).forEach(key =&gt; &#123; if (!process.env.hasOwnProperty(key)) &#123; process.env[key] = parsed[key]; &#125; &#125;); &#125; &#125;; //加载.env环境 loadEnv(baseEnvPath); //加载.env.local环境覆盖.env环境 loadEnv(localEnvPath);&#125; packages/umi/src/scripts/build.js构建执行脚本，实际调用 umi-build-dev 模块 12345678import yParser from 'yargs-parser';import buildDevOpts from '../buildDevOpts';process.env.NODE_ENV = 'production'; //设置环境为生产环境const args = yParser(process.argv.slice(2));const Service = require('umi-build-dev/lib/Service').default;new Service(buildDevOpts(args)).run('build', args); packages/umi/src/scripts/dev.js开发执行脚本，实际调用 umi-build-dev 模块 1234567891011121314151617import fork from 'umi-build-dev/lib/fork';const child = fork(require.resolve('./realDev.js'));child.on('message', data =&gt; &#123; if (process.send) &#123; process.send(data); &#125;&#125;);child.on('exit', code =&gt; &#123; if (code === 1) &#123; process.exit(code); &#125;&#125;);process.on('SIGINT', () =&gt; &#123; child.kill('SIGINT');&#125;); packages/umi/src/scripts/inspect.js检查内部 Webpack 配置脚本文件 12345678910111213import yParser from 'yargs-parser';import buildDevOpts from '../buildDevOpts';const args = yParser(process.argv.slice(2));if (args.mode === 'production') &#123; process.env.NODE_ENV = 'production';&#125; else &#123; process.env.NODE_ENV = 'development';&#125; //如果命令指定了mode=production，则切换换生产环境否则为开发环境const Service = require('umi-build-dev/lib/Service').default;new Service(buildDevOpts(args)).run('inspect', args); packages/umi/src/scripts/realDev.js1234567891011121314151617181920212223import yParser from 'yargs-parser';import buildDevOpts from '../buildDevOpts';let closed = false;// kill(2) Ctrl-Cprocess.once('SIGINT', () =&gt; onSignal('SIGINT'));// kill(3) Ctrl-\\process.once('SIGQUIT', () =&gt; onSignal('SIGQUIT'));// kill(15) defaultprocess.once('SIGTERM', () =&gt; onSignal('SIGTERM'));function onSignal(signal) &#123; if (closed) return; closed = true; process.exit(0);&#125;process.env.NODE_ENV = 'development';const args = yParser(process.argv.slice(2));const Service = require('umi-build-dev/lib/Service').default;new Service(buildDevOpts(args)).run('dev', args); 其他packages/umi/src/test.js测试脚本 12345678import yParser from 'yargs-parser';import buildDevOpts from '../buildDevOpts';process.env.NODE_ENV = 'development';const args = yParser(process.argv.slice(2));const Service = require('umi-build-dev/lib/Service').default;new Service(buildDevOpts(args)).run('test', args); packages/umi/src/babel.js12345678910111213export default function(context, opts = &#123;&#125;) &#123; return &#123; presets: [ [ require.resolve('babel-preset-umi'), &#123; ...opts, preact: true &#125; ] ] &#125;;&#125; packages/umi/src/createHistory.js1234567891011121314151617import createHistory from 'history/createBrowserHistory';import &#123; normalizePath &#125; from './utils';export default function(opts) &#123; const history = createHistory(opts); if (__UMI_HTML_SUFFIX) &#123; const oldPush = history.push; const oldReplace = history.replace; history.push = (path, state) =&gt; &#123; oldPush(normalizePath(path), state); &#125;; history.replace = (path, state) =&gt; &#123; oldReplace(normalizePath(path), state); &#125;; &#125; return history;&#125; packages/umi/src/prompt.js12import &#123; Prompt &#125; from 'react-router-dom';export default Prompt; packages/umi/src/renderRoutes.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import React from 'react';import &#123; Switch, Route, Redirect &#125; from 'react-router-dom';const RouteInstanceMap = &#123; get(key) &#123; return key._routeInternalComponent; &#125;, has(key) &#123; return key._routeInternalComponent !== undefined; &#125;, set(key, value) &#123; key._routeInternalComponent = value; &#125;&#125;;// Support pass props from layout to child routesconst RouteWithProps = (&#123; path, exact, strict, render, location, sensitive, ...rest &#125;) =&gt; ( &lt;Route path=&#123;path&#125; exact=&#123;exact&#125; strict=&#123;strict&#125; location=&#123;location&#125; sensitive=&#123;sensitive&#125; render=&#123;props =&gt; render(&#123; ...props, ...rest &#125;)&#125; /&gt;);function getCompatProps(props) &#123; const compatProps = &#123;&#125;; if (__UMI_BIGFISH_COMPAT) &#123; if (props.match &amp;&amp; props.match.params &amp;&amp; !props.params) &#123; compatProps.params = props.match.params; &#125; &#125; return compatProps;&#125;function withRoutes(route) &#123; if (RouteInstanceMap.has(route)) &#123; return RouteInstanceMap.get(route); &#125; const &#123; Routes &#125; = route; let len = Routes.length - 1; let Component = args =&gt; &#123; const &#123; render, ...props &#125; = args; return render(props); &#125;; while (len &gt;= 0) &#123; const AuthRoute = Routes[len]; const OldComponent = Component; Component = props =&gt; ( &lt;AuthRoute &#123;...props&#125;&gt; &lt;OldComponent &#123;...props&#125; /&gt; &lt;/AuthRoute&gt; ); len -= 1; &#125; const ret = args =&gt; &#123; const &#123; render, ...rest &#125; = args; return ( &lt;RouteWithProps &#123;...rest&#125; render=&#123;props =&gt; &#123; return &lt;Component &#123;...props&#125; route=&#123;route&#125; render=&#123;render&#125; /&gt;; &#125;&#125; /&gt; ); &#125;; RouteInstanceMap.set(route, ret); return ret;&#125;export default function renderRoutes(routes, extraProps = &#123;&#125;, switchProps = &#123;&#125;) &#123; return routes ? ( &lt;Switch &#123;...switchProps&#125;&gt; &#123;routes.map((route, i) =&gt; &#123; if (route.redirect) &#123; return &lt;Redirect key=&#123;route.key || i&#125; from=&#123;route.path&#125; to=&#123;route.redirect&#125; exact=&#123;route.exact&#125; strict=&#123;route.strict&#125; /&gt;; &#125; const RouteRoute = route.Routes ? withRoutes(route) : RouteWithProps; return ( &lt;RouteRoute key=&#123;route.key || i&#125; path=&#123;route.path&#125; exact=&#123;route.exact&#125; strict=&#123;route.strict&#125; sensitive=&#123;route.sensitive&#125; render=&#123;props =&gt; &#123; const childRoutes = renderRoutes( route.routes, &#123;&#125;, &#123; location: props.location &#125; ); if (route.component) &#123; const compatProps = getCompatProps(&#123; ...props, ...extraProps &#125;); const newProps = window.g_plugins.apply('modifyRouteProps', &#123; initialValue: &#123; ...props, ...extraProps, ...compatProps &#125;, args: &#123; route &#125; &#125;); return ( &lt;route.component &#123;...newProps&#125; route=&#123;route&#125;&gt; &#123;childRoutes&#125; &lt;/route.component&gt; ); &#125; else &#123; return childRoutes; &#125; &#125;&#125; /&gt; ); &#125;)&#125; &lt;/Switch&gt; ) : null;&#125; packages/umi/src/runtimePlugin.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import assert from 'assert';import isPlainObject from 'lodash/isPlainObject';let plugins = null;let validKeys = [];export function init(opts = &#123;&#125;) &#123; plugins = []; validKeys = opts.validKeys || [];&#125;export function use(plugin) &#123; Object.keys(plugin).forEach(key =&gt; &#123; // TODO: remove default // default 是为了兼容内部框架内置的一个 babel 插件问题 assert(validKeys.concat('default').indexOf(key) &gt; -1, `Invalid key $&#123;key&#125; from plugin`); &#125;); plugins.push(plugin);&#125;export function getItem(key) &#123; assert(validKeys.indexOf(key) &gt; -1, `Invalid key $&#123;key&#125;`); return plugins.filter(plugin =&gt; key in plugin).map(plugin =&gt; plugin[key]);&#125;function _compose(...funcs) &#123; if (funcs.length === 1) &#123; return funcs[0]; &#125; const last = funcs.pop(); return funcs.reduce((a, b) =&gt; () =&gt; b(a), last);&#125;export function compose(item, &#123; initialValue &#125;) &#123; if (typeof item === 'string') item = getItem(item); return () =&gt; &#123; return _compose(...item, initialValue)(); &#125;;&#125;export function apply(item, &#123; initialValue, args &#125;) &#123; if (typeof item === 'string') item = getItem(item); assert(Array.isArray(item), `item must be Array`); return item.reduce((memo, fn) =&gt; &#123; assert(typeof fn === 'function', `applied item must be function`); return fn(memo, args); &#125;, initialValue);&#125;export function applyForEach(item, &#123; initialValue &#125;) &#123; if (typeof item === 'string') item = getItem(item); assert(Array.isArray(item), `item must be Array`); item.forEach(fn =&gt; &#123; assert(typeof fn === 'function', `applied item must be function`); fn(initialValue); &#125;);&#125;// shadow mergeexport function mergeConfig(item) &#123; if (typeof item === 'string') item = getItem(item); assert(Array.isArray(item), `item must be Array`); return item.reduce((memo, config) =&gt; &#123; assert(isPlainObject(config), `Config is not plain object`); return &#123; ...memo, ...config &#125;; &#125;, &#123;&#125;);&#125; packages/umi/src/utils.js123456789101112131415161718function addHtmlAffix(pathname) &#123; if (pathname.slice(-1) === '/' || pathname.slice(-5) === '.html') &#123; return pathname; &#125; else &#123; return `$&#123;pathname&#125;.html`; &#125;&#125;export function normalizePath(path) &#123; if (typeof path === 'string') &#123; const [pathname, search] = path.split('?'); return `$&#123;addHtmlAffix(pathname)&#125;$&#123;search ? '?' : ''&#125;$&#123;search || ''&#125;`; &#125; return &#123; ...path, pathname: addHtmlAffix(path.pathname) &#125;;&#125; packages/umi-utils辅助 umi 的模块 packages/umi-utils/src/winPath.js123456//将Windows反斜杠路径转换为斜杠路径：foo\\\\bar➔foo/baimport slash from 'slash2';export default function(path) &#123; return slash(path);&#125; 总结 4/30通过源码和视频学习了命令行运行包文件，虽然只是打印了hello txp（demo）,阅读源码的同时对 node 印象更深刻了。疑惑的是 router 文件中的window.g_history不知道哪儿定义的，接下来需要看umi-build-dev模块了解构建运行的情况。 参考二配置 npmNode.js 中文网基于 umi 封装自己的框架：sekiro 学习 UMI（三）umi@2.6.17 运行 umi 代码阅读代码，看文档，总感觉缺点什么，经过云嫌和小虎两位大佬帮助，开始了 umi 代码调试之旅。其实上个月就想边运行边看代码，只是连安装开发依赖都没解决，所以拖到了现在。整个流程如下（也可以参考贡献文档）：1、克隆 umi 项目，在 umi 更目录装开发依赖，贡献文档是推荐用 yarn 装，不过要是网络不好，没有科学上网条件，会卡在装puppeteer上面，具体原因不是包上面是要下载Chromium的时候网络超时失败的。所以解决方案是通过 cnpm 装。 1cnpm i 2、安装各个包依赖，因为用的 lerna 作为包管理工具,所以运行lerna bootstrap进行安装，当然也可可以参照贡献文档使用yarn bootstrap装，这只是 umi 包的一个 script 转换而已。3、为了方便使用需要把 umi 链接到全局，链接到全局和全局装包效果是一样的。首先切换到 umi 包目录，cd packages/umi，然后可以使用npm link或者yarn link，建议使用 yarn，npm 链接有点慢。4、链接完成后就可以运行 umi 的命令了，我们试一试，结果提示找不到 lib 目录。因此我们需要切回根目录，运行yarn build对所有包进行构建生成 lib 目录文件，贡献文档命令是yarn build --watch可以实现实时构建。如此运行 umi 命令就和直接通过npm i umi -g命令安装一样了。 inspect目前能够运行本地 umi 代码了，可以在 umi 中加入console.log()来打印需要的参数，但是这样也不是很方面来理解代码。参照官方文档可以通过 inspect 进行断点调试。inspect 调试方法：1、全局安装 node-inspect 包 1npm i node-inspect -g 2、在 umi 包目录运行node --inspect-brk ./bin/umi dev,./bin/umi是运行文件相对执行环境位置,dev是执行参数。成功运行能够看到打印信息如下。 12Debugger listening on ws://127.0.0.1:9229/71f532b3-d619-4898-82ee-3145d817e5daFor help, see: https://nodejs.org/en/docs/inspector 3、进入调试器有两种方法，第一种是在谷歌浏览器输入chrome://inspect/#devices中打开，第二种是谷歌浏览器按 F12 唤醒开发者工具里打开，如下图。 图一 调试器如下图，基本操作和平时调试差不多。唯一遇到的坑就是 require 其他文件的时候进不去，试过在代码里加 debugger 也不行。最后发现左侧 Node 栏里面的文件是根据代码运行变化的，require 模块后 Node 栏里就会多出相应模块的代码，然后这个时候通过 Node 栏打开代码打断点即可调试。 图二 umi 命令内部运行过程目前主要看了 umi 包和 umi-build-dev 包，umi 主要提供运行时接口和编译时命令引导；umi-build-dev 包主要是编译时的工作，还包含内置插件（dev、build 等）。例如运行umi这个命令不加任何参数： 首先是进入 packages/umi/bin/umi.js 主文件，其功能是将命令分发到packages/umi/src/cli.js文件。 cli 文件对 umi 包进行检查，会提示版本更新。然后把命令分发到 script 文件执行命令，如果命令不存在直接执行命令。 执行命令文件packages/umi-build-dev/src/Service是一个类，构造函数会注册 Babel、解析用户配置、解析插件（解析插件会把内置插件和用户配置插件整合到一个数组中）。 然后命令执行运行类的 run 方法，如果 umi 命令没有参数则默认运行 help 命令。该方法会先初始化（加载环境.env、初始化插件、加载用户配置）。然后执行运行命令方法，该方法执行 umi 内部插件。 看过的一些源码及注释 packages/umi-build-devpackages/umi-build-dev/src/Service123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328import chalk from 'chalk'; //终端字符串样式做得很好(终端字符串颜色处理插件)//path.dirname() 方法返回 path 的目录名，类似于 Unix 的 dirname 命令。//path.join() 方法返回字符串拼接路径。import &#123; join, dirname &#125; from 'path';//existsSync 同步通过检查文件系统来测试给定的路径是否存在。//readFileSync 同步读取文件//writeFileSync 同步写入文件import &#123; existsSync, readFileSync, writeFileSync &#125; from 'fs';import assert from 'assert'; //此模块用于为您的应用程序编写单元测试import mkdirp from 'mkdirp'; //mkdir -p作用，确保目录名称存在，如果目录不存在的就新创建一个。//assign 浅拷贝//cloneDeep 深拷贝import &#123; assign, cloneDeep &#125; from 'lodash';import &#123; parse &#125; from 'dotenv'; //Dotenv是一个零依赖模块，可以将.env文件中的环境变量加载到process.envimport signale from 'signale'; //可记录和可配置到核心，signale可用于记录目的，状态报告，以及处理其他节点模块和应用程序的输出呈现过程。终端中命令执行成功失败异常等的状态//deprecate 用于终端上提示方法被弃用,传入(方法名，...想要提示的其他信息),调用方法终端输出提示信息。import &#123; deprecate &#125; from 'umi-utils';import getPaths from './getPaths';import getPlugins from './getPlugins';import PluginAPI from './PluginAPI';import UserConfig from './UserConfig';import registerBabel from './registerBabel';import getCodeFrame from './utils/getCodeFrame';const debug = require('debug')('umi-build-dev:Service');//服务类export default class Service &#123; //构造函数传入目录 constructor(&#123; cwd &#125;) &#123; //cwd为app根目录 //process.cwd() 方法返回 Node.js 进程的当前工作目录。 this.cwd = cwd || process.cwd(); //如果不传入cwd，cwd为Node.js 进程的当前工作目录. try &#123; this.pkg = require(join(this.cwd, 'package.json')); // 引入项目package.json，pkg为json对象 &#125; catch (e) &#123; this.pkg = &#123;&#125;; //不存在package.json则pkg为空对象 &#125; registerBabel(&#123; cwd: this.cwd &#125;); //注册Babel this.commands = &#123;&#125;; this.pluginHooks = &#123;&#125;; this.pluginMethods = &#123;&#125;; this.generators = &#123;&#125;; // 解析用户配置 this.config = UserConfig.getConfig(&#123; cwd: this.cwd, service: this &#125;); debug(`user config: $&#123;JSON.stringify(this.config)&#125; `); // 解析插件，内置插件和用户插件解析 this.plugins = this.resolvePlugins(); this.extraPlugins = []; debug(`plugins: $&#123;this.plugins.map(p =&gt; p.id).join(' | ')&#125; `); // 相对路径 this.paths = getPaths(this); &#125; resolvePlugins() &#123; try &#123; assert(Array.isArray(this.config.plugins || []), `Configure item $&#123;chalk.underline.cyan('plugins')&#125; should be Array, but got $&#123;chalk.red(typeof this.config.plugins)&#125; `); return getPlugins(&#123; cwd: this.cwd, plugins: this.config.plugins || [] &#125;); &#125; catch (e) &#123; if (process.env.UMI_TEST) &#123; throw new Error(e); &#125; else &#123; signale.error(e); process.exit(1); &#125; &#125; &#125; //解析插件 initPlugin(plugin) &#123; const &#123; id, apply, opts &#125; = plugin; try &#123; assert( typeof apply === 'function', `plugin must export a function, e.g.export default function (api) &#123; // Implement functions via api&#125;`.trim() ); const api = new Proxy(new PluginAPI(id, this), &#123; get: (target, prop) =&gt; &#123; if (this.pluginMethods[prop]) &#123; return this.pluginMethods[prop]; &#125; if ( [ // methods 'changePluginOption', 'applyPlugins', '_applyPluginsAsync', 'writeTmpFile', // properties 'cwd', 'config', 'webpackConfig', 'pkg', 'paths', 'routes', // dev methods 'restart', 'printError', 'printWarn', 'refreshBrowser', 'rebuildTmpFiles', 'rebuildHTML' ].includes(prop) ) &#123; if (typeof this[prop] === 'function') &#123; return this[prop].bind(this); &#125; else &#123; return this[prop]; &#125; &#125; else &#123; return target[prop]; &#125; &#125; &#125;); api.onOptionChange = fn =&gt; &#123; assert(typeof fn === 'function', `The first argument for api.onOptionChange should be function in $&#123;id&#125;.`); plugin.onOptionChange = fn; &#125;; apply(api, opts); plugin._api = api; &#125; catch (e) &#123; if (process.env.UMI_TEST) &#123; throw new Error(e); &#125; else &#123; signale.error( `Plugin $&#123;chalk.cyan.underline(id)&#125; initialize failed$&#123;getCodeFrame(e, &#123; cwd: this.cwd &#125;)&#125;`.trim() ); debug(e); process.exit(1); &#125; &#125; &#125; //初始化插件 initPlugins() &#123; this.plugins.forEach(plugin =&gt; &#123; this.initPlugin(plugin); &#125;); let count = 0; while (this.extraPlugins.length) &#123; const extraPlugins = cloneDeep(this.extraPlugins); this.extraPlugins = []; extraPlugins.forEach(plugin =&gt; &#123; this.initPlugin(plugin); this.plugins.push(plugin); &#125;); count += 1; assert(count &lt;= 10, `插件注册死循环？`); &#125; // Throw error for methods that can't be called after plugins is initialized this.plugins.forEach(plugin =&gt; &#123; ['onOptionChange', 'register', 'registerMethod', 'registerPlugin'].forEach(method =&gt; &#123; plugin._api[method] = () =&gt; &#123; throw new Error(`api.$&#123;method&#125; () should not be called after plugin is initialized.`); &#125;; &#125;); &#125;); &#125; //初始化插件集 changePluginOption(id, newOpts) &#123; assert(id, `id must supplied`); const plugin = this.plugins.filter(p =&gt; p.id === id)[0]; assert(plugin, `plugin $&#123;id&#125; not found`); plugin.opts = newOpts; if (plugin.onOptionChange) &#123; plugin.onOptionChange(newOpts); &#125; else &#123; this.restart(`plugin $&#123;id&#125; 's option changed`); &#125; &#125; applyPlugins(key, opts = &#123;&#125;) &#123; debug(`apply plugins $&#123;key&#125;`); return (this.pluginHooks[key] || []).reduce((memo, &#123; fn &#125;) =&gt; &#123; try &#123; return fn(&#123; memo, args: opts.args &#125;); &#125; catch (e) &#123; console.error(chalk.red(`Plugin apply failed: $&#123;e.message&#125;`)); throw e; &#125; &#125;, opts.initialValue); &#125; async _applyPluginsAsync(key, opts = &#123;&#125;) &#123; debug(`apply plugins async $&#123;key&#125;`); const hooks = this.pluginHooks[key] || []; let memo = opts.initialValue; for (const hook of hooks) &#123; const &#123; fn &#125; = hook; memo = await fn(&#123; memo, args: opts.args &#125;); &#125; return memo; &#125; loadEnv() &#123; const basePath = join(this.cwd, '.env'); //基础配置路径 const localPath = `$&#123;basePath&#125;.local`; //本地配置路径 const load = path =&gt; &#123; if (existsSync(path)) &#123; debug(`load env from $&#123;path&#125;`); const parsed = parse(readFileSync(path, 'utf-8')); Object.keys(parsed).forEach(key =&gt; &#123; if (!process.env.hasOwnProperty(key)) &#123; process.env[key] = parsed[key]; &#125; &#125;); &#125; &#125;; load(basePath); //加载基础配置 load(localPath); //加载本地配置，覆盖基础配置 &#125; //加载环境 writeTmpFile(file, content) &#123; const &#123; paths &#125; = this; const path = join(paths.absTmpDirPath, file); mkdirp.sync(dirname(path)); writeFileSync(path, content, 'utf-8'); &#125; init() &#123; // 加载环境 this.loadEnv(); // 初始化插件 this.initPlugins(); // 加载用户配置 const userConfig = new UserConfig(this); const config = userConfig.getConfig(&#123; force: true &#125;); mergeConfig(this.config, config); this.userConfig = userConfig; if (config.browserslist) &#123; deprecate('config.browserslist', 'use config.targets instead'); &#125; debug('got user config'); debug(this.config); // assign user's outputPath config to paths object if (config.outputPath) &#123; const &#123; paths &#125; = this; paths.outputPath = config.outputPath; paths.absOutputPath = join(paths.cwd, config.outputPath); &#125; debug('got paths'); debug(this.paths); &#125; //初始化 registerCommand(name, opts, fn) &#123; if (typeof opts === 'function') &#123; fn = opts; opts = null; &#125; opts = opts || &#123;&#125;; assert(!(name in this.commands), `Command $&#123;name&#125; exists, please select another one.`); this.commands[name] = &#123; fn, opts &#125;; &#125; //注册命令，在PluginAPI中调用 run(name = 'help', args) &#123; this.init(); //初始化 return this.runCommand(name, args); //运行help命令 &#125; //启动servers runCommand(rawName, rawArgs) &#123; debug(`raw command name: $&#123;rawName&#125;, args: $&#123;JSON.stringify(rawArgs)&#125;`); const &#123; name, args &#125; = this.applyPlugins('_modifyCommand', &#123; initialValue: &#123; name: rawName, args: rawArgs &#125; &#125;); debug(`run $&#123;name&#125; with args $&#123;JSON.stringify(args)&#125;`); const command = this.commands[name]; if (!command) &#123; signale.error(`Command $&#123;chalk.underline.cyan(name)&#125; does not exists`); process.exit(1); &#125; const &#123; fn, opts &#125; = command; if (opts.webpack) &#123; // webpack config this.webpackConfig = require('./getWebpackConfig').default(this); &#125; return fn(args); &#125; //运行命令&#125;function mergeConfig(oldConfig, newConfig) &#123; Object.keys(oldConfig).forEach(key =&gt; &#123; if (!(key in newConfig)) &#123; delete oldConfig[key]; &#125; &#125;); assign(oldConfig, newConfig); return oldConfig;&#125; //合并配置项 packages/umi-build-dev/src/registerBabel123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import &#123; join, isAbsolute &#125; from 'path'; //引入拼接路径模块和判断是否为绝对路劲模块import &#123; existsSync &#125; from 'fs'; //同步检查路肩是否存在模块import registerBabel from 'af-webpack/registerBabel';import &#123; winPath &#125; from 'umi-utils';//获取umi配置文件路径的数组import &#123; getConfigPaths &#125; from 'umi-core/lib/getUserConfig';let files = null;function initFiles(cwd) &#123; if (files) return; files = getConfigPaths(cwd); //传入node运行时路径&#125; //初始化文件，若文件存在则忽略export function addBabelRegisterFiles(extraFiles, &#123; cwd &#125;) &#123; initFiles(cwd); files.push(...extraFiles);&#125;export default function(&#123; cwd &#125;) &#123; initFiles(cwd); const only = files.map(f =&gt; &#123; const fullPath = isAbsolute(f) ? f : join(cwd, f); return winPath(fullPath); &#125;); //转化路径 let absSrcPath = join(cwd, 'src'); //获取src目录路径 if (!existsSync(absSrcPath)) &#123; absSrcPath = cwd; &#125; //如果不存在src目录则把根目录作为src目录 registerBabel(&#123; // only suport glob // ref: https://babeljs.io/docs/en/next/babel-core.html#configitem-type only, babelPreset: [ require.resolve('babel-preset-umi'), &#123; env: &#123; targets: &#123; node: 8 &#125; &#125;, transformRuntime: false &#125; ], babelPlugins: [ [ require.resolve('babel-plugin-module-resolver'), &#123; alias: &#123; '@': absSrcPath &#125; &#125; ] ] &#125;);&#125; packages/umi-build-dev/src/UserConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185import &#123; join &#125; from 'path';import requireindex from 'requireindex';import chalk from 'chalk';import didyoumean from 'didyoumean';import &#123; cloneDeep &#125; from 'lodash';import signale from 'signale';import getUserConfig, &#123; getConfigPaths, getConfigFile, getConfigByConfigFile, cleanConfigRequireCache &#125; from 'umi-core/lib/getUserConfig';import &#123; watch, unwatch &#125; from './getConfig/watch';import isEqual from './isEqual';class UserConfig &#123; static getConfig(opts = &#123;&#125;) &#123; const &#123; cwd, service &#125; = opts; return getUserConfig(&#123; cwd, defaultConfig: service.applyPlugins('modifyDefaultConfig', &#123; initialValue: &#123;&#125; &#125;) &#125;); &#125; constructor(service) &#123; this.service = service; this.configFailed = false; this.config = null; this.file = null; this.relativeFile = null; this.watch = watch; this.unwatch = unwatch; this.initConfigPlugins(); &#125; initConfigPlugins() &#123; const map = requireindex(join(__dirname, 'getConfig/configPlugins')); let plugins = Object.keys(map).map(key =&gt; &#123; return map[key].default; &#125;); plugins = this.service.applyPlugins('_registerConfig', &#123; initialValue: plugins &#125;); this.plugins = plugins.map(p =&gt; p(this)); &#125; printError(messages) &#123; if (this.service.printError) this.service.printError(messages); &#125; getConfig(opts = &#123;&#125;) &#123; const &#123; paths, cwd &#125; = this.service; const &#123; force, setConfig &#125; = opts; const defaultConfig = this.service.applyPlugins('modifyDefaultConfig', &#123; initialValue: &#123;&#125; &#125;); const file = getConfigFile(cwd); this.file = file; if (!file) &#123; return defaultConfig; &#125; // 强制读取，不走 require 缓存 if (force) &#123; cleanConfigRequireCache(cwd); &#125; let config = null; const relativeFile = file.replace(`$&#123;paths.cwd&#125;/`, ''); this.relativeFile = relativeFile; const onError = (e, file) =&gt; &#123; const msg = `配置文件 \"$&#123;file.replace(`$&#123;paths.cwd&#125;/`, '')&#125;\" 解析出错，请检查语法。\\r\\n$&#123;e.toString()&#125;`; this.printError(msg); throw new Error(msg); &#125;; config = getConfigByConfigFile(file, &#123; defaultConfig, onError &#125;); config = this.service.applyPlugins('_modifyConfig', &#123; initialValue: config &#125;); // Validate for (const plugin of this.plugins) &#123; const &#123; name, validate &#125; = plugin; if (config[name] &amp;&amp; validate) &#123; try &#123; plugin.validate.call(&#123; cwd &#125;, config[name]); &#125; catch (e) &#123; // 校验出错后要把值设到缓存的 config 里，确保 watch 判断时才能拿到正确的值 if (setConfig) &#123; setConfig(config); &#125; this.printError(e.message); throw new Error(`配置 $&#123;name&#125; 校验失败, $&#123;e.message&#125;`); &#125; &#125; &#125; // 找下不匹配的 name const pluginNames = this.plugins.map(p =&gt; p.name); Object.keys(config).forEach(key =&gt; &#123; if (!pluginNames.includes(key)) &#123; if (opts.setConfig) &#123; opts.setConfig(config); &#125; const affixmsg = `选择 \"$&#123;pluginNames.join(', ')&#125;\" 中的一项`; const guess = didyoumean(key, pluginNames); const midMsg = guess ? `你是不是想配置 \"$&#123;guess&#125;\" ？ 或者` : '请'; const msg = `\"$&#123;relativeFile&#125;\" 中配置的 \"$&#123;key&#125;\" 并非约定的配置项，$&#123;midMsg&#125;$&#123;affixmsg&#125;`; this.printError(msg); throw new Error(msg); &#125; &#125;); return config; &#125; setConfig(config) &#123; this.config = config; &#125; watchWithDevServer() &#123; // 配置插件的监听 for (const plugin of this.plugins) &#123; if (plugin.watch) &#123; plugin.watch(); &#125; &#125; // 配置文件的监听 this.watchConfigs((event, path) =&gt; &#123; signale.debug(`[$&#123;event&#125;] $&#123;path&#125;`); try &#123; const newConfig = this.getConfig(&#123; force: true, setConfig: newConfig =&gt; &#123; this.config = newConfig; &#125; &#125;); // 从失败中恢复过来，需要 reload 一次 if (this.configFailed) &#123; this.configFailed = false; this.service.refreshBrowser(); &#125; const oldConfig = cloneDeep(this.config); this.config = newConfig; for (const plugin of this.plugins) &#123; const &#123; name &#125; = plugin; if (!isEqual(newConfig[name], oldConfig[name])) &#123; this.service.config[name] = newConfig[name]; this.service.applyPlugins('onConfigChange', &#123; args: &#123; newConfig &#125; &#125;); if (plugin.onChange) &#123; plugin.onChange(newConfig, oldConfig); &#125; &#125; &#125; &#125; catch (e) &#123; this.configFailed = true; console.error(chalk.red(`watch handler failed, since $&#123;e.message&#125;`)); console.error(e); &#125; &#125;); &#125; watchConfigs(handler) &#123; const &#123; cwd &#125; = this.service; const watcher = this.watch('CONFIG_FILES', getConfigPaths(cwd)); if (watcher) &#123; watcher.on('all', handler); &#125; &#125;&#125;export default UserConfig; packages/umi-build-dev/src/getPaths123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162```#### packages/umi-build-dev/src/getPlugins```js//实现节点require.resolve() 算法 ，以便您可以require.resolve()异步和同步代表文件import resolve from 'resolve';//assert来自Node.js 的模块，用于浏览器。使用browserify，只需require('assert')或使用assert全局，您将获得此模块。目标是提供尽可能与Node.js assertAPI功能相同的API。阅读API文档的官方文档。import assert from 'assert';import chalk from 'chalk'; //终端字符串样式修改import registerBabel, &#123; addBabelRegisterFiles &#125; from './registerBabel';import isEqual from './isEqual';import getCodeFrame from './utils/getCodeFrame';const debug = require('debug')('umi-build-dev:getPlugin');export default function(opts = &#123;&#125;) &#123; const &#123; cwd, plugins = [] &#125; = opts; // 内置插件 const builtInPlugins = [ './plugins/commands/dev', './plugins/commands/build', './plugins/commands/inspect', './plugins/commands/test', './plugins/commands/help', './plugins/commands/generate', './plugins/commands/rm', './plugins/commands/config', './plugins/commands/block', // './plugins/commands/ui', './plugins/commands/version', './plugins/global-js', './plugins/global-css', './plugins/base', './plugins/mountElementId', './plugins/mock', './plugins/proxy', './plugins/history', './plugins/afwebpack-config', './plugins/mountElementId', './plugins/404', // 404 must after mock './plugins/targets' ]; const pluginsObj = [ // builtIn 的在最前面 ...builtInPlugins.map(p =&gt; &#123; let opts; if (Array.isArray(p)) &#123; opts = p[1]; // eslint-disable-line p = p[0]; &#125; const apply = require(p); // eslint-disable-line return &#123; id: p.replace(/^.\\//, 'built-in:'), apply: apply.default || apply, opts &#125;; &#125;), ...getUserPlugins(process.env.UMI_PLUGINS ? process.env.UMI_PLUGINS.split(',') : [], &#123; cwd &#125;), ...getUserPlugins(plugins, &#123; cwd &#125;) ]; debug(`plugins: \\n$&#123;pluginsObj.map(p =&gt; ` $&#123;p.id&#125;`).join('\\n')&#125;`); return pluginsObj;&#125;function pluginToPath(plugins, &#123; cwd &#125;) &#123; return (plugins || []).map(p =&gt; &#123; assert(Array.isArray(p) || typeof p === 'string', `Plugin config should be String or Array, but got $&#123;chalk.red(typeof p)&#125;`); if (typeof p === 'string') &#123; p = [p]; &#125; const [path, opts] = p; try &#123; return [ resolve.sync(path, &#123; basedir: cwd &#125;), opts ]; &#125; catch (e) &#123; throw new Error( `Plugin $&#123;chalk.underline.cyan(path)&#125; can't be resolved Please try the following solutions: 1. checkout the plugins config in your config file (.umirc.js or config/config.js) $&#123;path.charAt(0) !== '.' &amp;&amp; path.charAt(0) !== '/' ? `2. install $&#123;chalk.underline.cyan(path)&#125; via npm/yarn` : ''&#125;`.trim() ); &#125; &#125;);&#125;function getUserPlugins(plugins, &#123; cwd &#125;) &#123; const pluginPaths = pluginToPath(plugins, &#123; cwd &#125;); // 用户给的插件需要做 babel 转换 if (pluginPaths.length) &#123; addBabelRegisterFiles(pluginPaths.map(p =&gt; p[0]), &#123; cwd &#125;); registerBabel(&#123; cwd &#125;); &#125; return pluginPaths.map(p =&gt; &#123; const [path, opts] = p; let apply; try &#123; apply = require(path); // eslint-disable-line &#125; catch (e) &#123; throw new Error( `Plugin $&#123;chalk.cyan.underline(path)&#125; require failed$&#123;getCodeFrame(e)&#125; `.trim() ); &#125; return &#123; id: path.replace(makesureLastSlash(cwd), 'user:'), apply: apply.default || apply, opts &#125;; &#125;);&#125;function resolveIdAndOpts(&#123; id, opts &#125;) &#123; return &#123; id, opts &#125;;&#125;function toIdStr(plugins) &#123; return plugins.map(p =&gt; p.id).join('^^');&#125;/** * 返回结果： * pluginsChanged: true | false * optionChanged: [ 'a', 'b' ] */export function diffPlugins(newOption, oldOption, &#123; cwd &#125;) &#123; const newPlugins = getUserPlugins(newOption, &#123; cwd &#125;).map(resolveIdAndOpts); const oldPlugins = getUserPlugins(oldOption, &#123; cwd &#125;).map(resolveIdAndOpts); if (newPlugins.length !== oldPlugins.length) &#123; return &#123; pluginsChanged: true &#125;; &#125; else if (toIdStr(newPlugins) !== toIdStr(oldPlugins)) &#123; return &#123; pluginsChanged: true &#125;; &#125; else &#123; return &#123; optionChanged: newPlugins.filter((p, index) =&gt; &#123; return !isEqual(newPlugins[index].opts, oldPlugins[index].opts); &#125;) &#125;; &#125;&#125;function makesureLastSlash(path) &#123; return path.slice(-1) === '/' ? path : `$&#123;path&#125;/`;&#125; packages/umi-build-dev/src/utils/deprecate用于终端上提示方法被弃用,传入(方法名，…想要提示的其他信息),调用方法终端输出提示信息。 1234567891011121314151617181920212223242526272829303132//process.platform属性返回字符串，标识Node.js进程运行其上的操作系统平台。const isWindows = typeof process !== 'undefined' &amp;&amp; process.platform === 'win32';const EOL = isWindows ? '\\r\\n' : '\\n';//判断是否是windows更具系统选择换行符号const hits = &#123;&#125;;export default function deprecate(methodName, ...args) &#123; if (hits[methodName]) return; hits[methodName] = true; //process.stderr 属性返回连接到 stderr (fd 2) 的流。 它是一个 net.Socket 流（也就是双工流），除非 fd 2 指向一个文件，在这种情况下它是一个可写流。console.error() 内部分别是由它实现的。 const stream = process.stderr; //判断 Node.js 是否在 TTY 上下文中运行的首选方法是检查 process.stdout.isTTY 属性的值是否为 true： const color = stream.isTTY &amp;&amp; '\\x1b[31;1m'; //如果上下文是终端设置亮黄色加粗字体 stream.write(EOL); //终端写入换行 if (color) &#123; stream.write(color); &#125; stream.write(`Warning: $&#123;methodName&#125; has been deprecated.`); //警告方法名已经被弃用 stream.write(EOL); //换行 args.forEach(message =&gt; &#123; stream.write(message); //打印参数 stream.write(EOL); //换行 &#125;); if (color) &#123; stream.write('\\x1b[0m'); &#125; //把字体还原 stream.write(EOL); stream.write(EOL);&#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://shawdanon.github.io/tags/笔记/"}]},{"title":"typescript","date":"2019-02-25T16:00:00.000Z","path":"2019/typescript/","text":"typescript 学习记… 基础类型通过冒号+类型来定义变量的类型。 1let decLiteral: number = 6; //数字类型的列子 布尔值（boolean）数字（number）字符串（string）Array（数组）有两种定义方式： 元素类型[] 1let list: number[] = [1, 2, 3]; Array&lt;元素类型&gt; 1let list: Array&lt;number&gt; = [1, 2, 3]; 元组 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 1let x: [string, number] = ['hello', 10]; 当访问一个越界的元素，会使用联合类型替代。 123let x: [string, number] = ['hello', 10];x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型x[6] = true; // Error, 布尔不是(string | number)类型 枚举枚举类型可以为一组数值赋予友好的名字。 1234567enum Color &#123; Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); // 显示'Green'因为上面代码里它的值是2 Any任何类型。 Void没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void。 Null 和 Undefined默认情况下 null 和 undefined 是所有类型的子类型。 当你指定了–strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。 Nevernever 类型表示的是那些永不存在的值的类型。 123456789function error(message: string): never &#123; throw new Error(message);&#125; // 返回never的函数必须存在无法达到的终点function fail() &#123; return error('Something failed');&#125; // 推断的返回值类型为neverfunction infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; // 返回never的函数必须存在无法达到的终点 Objectobject 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。 类型断言类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 类型断言有两种形式。其一是“尖括号”语法 12let someValue: any = 'this is a string';let strLength: number = (&lt;string&gt;someValue).length; 另一个为 as 语法。 12let someValue: any = 'this is a string';let strLength: number = (someValue as string).length; 接口TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 12345678interface LabelledValue &#123; label: string;&#125; //定义function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125; //使用let myObj = &#123; size: 10, label: 'Size 10 Object' &#125;;printLabel(myObj); 可选属性接口里的属性不全都是必需的。有些是只在某些条件下存在，或者根本不存在。 1234interface SquareConfig &#123; color?: string; width?: number;&#125; 只读属性一些对象属性只能在对象刚刚创建的时候修改其值。 1234interface Point &#123; readonly x: number; readonly y: number;&#125; 额外的属性检查访问 interface 未定义的属性时会报错，有以下三种方法绕过， 方法一：类型断言 12345678910interface IFoo &#123; label: string;&#125;function bar(foo: IFoo) &#123; console.log(foo.label);&#125;bar(&#123; label: 'foooo', size: 10&#125; as IFoo); 方法二：在 interface 里定义额外属性 1234567891011interface IFoo &#123; label: string; [propName: string]: any;&#125;function bar(foo: IFoo) &#123; console.log(foo.label);&#125;bar(&#123; label: 'foooo', size: 10&#125;); 方法三：赋值给另一属性 1234567891011interface IFoo &#123; label: string;&#125;function bar(foo: IFoo) &#123; console.log(foo.label);&#125;const foo = &#123; label: 'foooo', size: 10&#125;;bar(foo); 函数类型12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125;; 可索引的类型123456interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = ['Bob', 'Fred'];let myStr: string = myArray[0]; TypeScript 支持两种索引签名：字符串和数字。 类类型1234567interface ClockInterface &#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime: Date; constructor(h: number, m: number) &#123;&#125;&#125; 当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 继承接口123456789interface Shape &#123; color: string;&#125;interface Square extends Shape &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = 'blue';square.sideLength = 10; 混合类型一个对象可以同时做为函数和对象使用，并带有额外的属性。 123456789101112131415interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function(start: number) &#123;&#125;; counter.interval = 123; counter.reset = function() &#123;&#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 1234567891011121314151617class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123;&#125;&#125;class TextBox extends Control &#123; select() &#123;&#125;&#125;// 错误：“Image”类型缺少“state”属性。class Image implements SelectableControl &#123; select() &#123;&#125;&#125;class Location &#123;&#125; 类传统的 JavaScript 程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 12345678910class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return 'Hello, ' + this.greeting; &#125;&#125;let greeter = new Greeter('world'); 继承子类的 constructor 里可以用 super(参数) 或 super.bar(参数) 来执行父类的 constructor。 公共，私有与受保护的修饰符public：公有，可以在内部、派生类、声明外部访问； private：私有，可以在内部访问； protected：保护，可以在内部、派生类访问； readonly 修饰符你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 123456789class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus('Man with the 8 strong legs');dad.name = 'Man with the 3-piece suit'; // 错误! name 是只读的. 参数属性在上面的例子中，我们必须在 Octopus 类里定义一个只读成员 name 和一个参数为 theName 的构造函数，并且立刻将 theName 的值赋给 name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus 类的修改版，使用了参数属性： 1234class Octopus &#123; readonly numberOfLegs: number = 8; constructor(readonly name: string) &#123;&#125;&#125; 静态属性123456class Foo &#123; static bar: 'world'; constructor() &#123; console.log(Foo.bar); &#125;&#125; 抽象类123456abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log('roaming the earch...'); &#125;&#125; 函数函数的函数类型123456function add(x: number, y: number): number &#123; return x + y;&#125;let myAdd = function(x: number, y: number): number &#123; return x + y;&#125;; 可选参数和默认参数1234567function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + ' ' + lastName; else return firstName;&#125;function buildName(firstName: string, lastName = 'Smith') &#123; return firstName + ' ' + lastName;&#125; 剩余参数123function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + ' ' + restOfName.join(' ');&#125; 泛型软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 返回值的类型与传入参数的类型是相同的。 12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; //定义let output = identity&lt;string&gt;('myString'); // 使用let output = identity('myString'); // 普遍使用 使用泛型变量我们把泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性。 12345678function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125;function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125; 泛型类123456789class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y;&#125;; 泛型约束我们需要传入符合约束类型的值，必须包含必须的属性. 123456789interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125;loggingIdentity(3); // Error, number doesn't have a .length propertyloggingIdentity(&#123; length: 10, value: 3 &#125;); 枚举类型使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 数字枚举123456enum Direction &#123; Up = 1, //初始化器 Down, Left, Right&#125; //不使用初始化器从0开始 字符串枚举在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 123456enum Direction &#123; Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT'&#125; 异构枚举从技术的角度来说，枚举可以混合字符串和数字成员，但不推荐。 1234enum BooleanLikeHeterogeneousEnum &#123; No = 0, Yes = \"YES\",&#125; 类型推论最佳通用类型当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。 1let x = [0, 1, null]; 如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型 上下文类型TypeScript 类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。 Symbolssymbol 类型的值是通过 Symbol 构造函数创建的。 12let sym1 = Symbol();let sym2 = Symbol('key'); // 可选的字符串key Symbols 是不可改变且唯一的。 123let sym2 = Symbol('key');let sym3 = Symbol('key');sym2 === sym3; // false, symbols是唯一的 像字符串一样，symbols 也可以被用做对象属性的键。 12345let sym = Symbol();let obj = &#123; [sym]: 'value'&#125;;console.log(obj[sym]); // \"value\" Symbols 也可以与计算出的属性名声明相结合来声明对象的属性和类成员。 12345678const getClassNameSymbol = Symbol();class C &#123; [getClassNameSymbol]() &#123; return 'C'; &#125;&#125;let c = new C();let className = c[getClassNameSymbol](); // \"C\" 模块模块是自声明的；两个模块之间的关系是通过在文件级别上使用 imports 和 exports 建立的。 导出任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加 export 关键字来导出。 12export &#123; a &#125;; //导出export &#123; a as b &#125;; //导出重命名 一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：export \\* from &quot;module&quot;。 导入模块的导入操作与导出一样简单。 可以使用以下 import 形式之一来导入其它模块中的导出内容。 123import &#123; ZipCodeValidator &#125; from './ZipCodeValidator'; //导入某个内容import &#123; ZipCodeValidator as ZCV &#125; from './ZipCodeValidator'; //导入内容重命名import * as validator from './ZipCodeValidator'; //将整个模块导入到一个变量，并通过它来访问模块的导出部分 默认导出每个模块都可以有一个 default 导出。 12345declare let $: JQuery;export default $;import $ from 'JQuery';$('button.continue').html('Next Step...'); 命名空间这篇文章描述了如何在 TypeScript 里使用命名空间（之前叫做“内部模块”）来组织你的代码。 就像我们在术语说明里提到的那样，“内部模块”现在叫做“命名空间”。 123456namespace Foo &#123; export function bar() &#123; console.log(1); &#125;&#125;Foo.bar(); 别名另一种简化命名空间操作的方法是使用 import q = x.y.z 给常用的对象起一个短的名字。 12345678namespace Shapes &#123; export namespace Polygons &#123; export class Triangle &#123;&#125; export class Square &#123;&#125; &#125;&#125;import polygons = Shapes.Polygons;let sq = new polygons.Square(); // Same as \"new Shapes.Polygons.Square()\" 使用其它的 JavaScript 库12345678910111213141516declare namespace D3 &#123; export interface Selectors &#123; select: &#123; (selector: string): Selection; (element: EventTarget): Selection; &#125;; &#125; export interface Event &#123; x: number; y: number; &#125; export interface Base extends Selectors &#123; event: Event; &#125;&#125;declare var d3: D3.Base; 命名空间和模块使用命名空间命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。 使用模块像命名空间一样，模块可以包含代码和声明。 不同的是模块可以 声明它的依赖。 陷阱不要用/// &lt;reference /&gt; 引模块，而是去引 d.ts 文件。 尽量别用命名空间。","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://shawdanon.github.io/tags/笔记/"}]},{"title":"flutter折腾记","date":"2019-02-13T16:00:00.000Z","path":"2019/flutter/","text":"期望 flutter 统一 JS 开发桌面客户端和 APP… 环境配置Windows 环境配置 安装 jdk 安装 flutter 安装 Android Studio 安装 sdk 创建一个 demo 安装模拟器 通过 vscode 开发 flutter 安装 jdk 很简单，通过oracle 官网下载。点击下一步即可安装完成（PS：最后 jre 可以取消安装，避免重复安装）。为了方便使用配置好环境变量。 安装 flutter 也简单，通过flutter 官网下载。得到压缩包，在任意位置解压即可使用。在flutter\\bin运行flutter doctor可以查看还需要安装哪儿些环境。为了方便使用将flutter\\bin加入环境变量。从此命令可以得知我们还需要安装安卓 SDK 和安卓模拟器。 安装 Android Studio 也简单（在翻墙的情况下），在安卓官网下载，得到软件一路下一步即可安装。安装完成后需要安装 sdk。如果你不会翻墙，那么在安卓中文社区也能下载 Android Studio，安装 sdk 前需要设置 host 文件，给 host 文件添加203.208.41.37 dl.google.com,ip 地址是通过站长工具检测dl.google.com这个域名得到响应最快的国内 ip 地址，配置好 host 文件后再下载 sdk 速度就很快了。 安装完 sdk 后运行flutter doctor发现需要安装安卓证书，运行flutter doctor --android-licenses命令安装证书，提示选择 y。 接下来通过 Android Studio 来创建一个 demo，首先安装 Android Studio 的插件 flutter，安装 flutter 会自动安装 dart，安装完重启 Android Studio 会在启动界面看到多出了个选项start a new flutter project。通过这个选项创建一个 flutter APP。 建好项目后，还需要项目运行环境，安卓模拟器，在 tools 里面选择 AVD manager，新加一个安卓模拟器，选择默认设备点击下一步，选择模拟器，模拟器旁边对应的安卓版本，还有 download 标识，标识没有下载，点击 download 下载模拟器（PS:如果不是 Intel 平台会比较麻烦），下载好后选择该模拟器，点击完成创建一个安卓模拟器。点击运行模拟器即可打开模拟器。 打开模拟器后就可以使用 debug 来浏览项目了。如果没有翻墙，需要修改项目文件android-&gt;build.gradle。将 12google();jcenter(); 替换为 123maven &#123; url 'https://maven.aliyun.com/repository/google' &#125;maven &#123; url 'https://maven.aliyun.com/repository/jcenter' &#125;maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public'&#125; 如此就能成功运行起程序。 作为 vscode 重度使用人来说换个编辑器还是有点不习惯的，那么怎么在 vscode 上开发 flutter 呢？首先我们需要解决脱离 Android Studio 能够运行起安卓模拟器。创建批处理文件 1C:\\Users\\ShawDanon\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -netdelay none -netspeed full -avd Nexus_5X_API_28 C:\\Users\\ShawDanon\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe这个是安卓 sdk 路径下的可执行程序，需要改成你的路径。Nexus_5X_API_28是模拟器名字（名字本来是Nexus 5X API 28，空格使用下划线代替），在创建模拟器的时候可以设置。然后运行批处理文件即可打开安卓模拟器。 通过 vscode 打开刚才创建的项目，发现没有高亮代码。然后安装插件 flutter，安装完成重启 vscode 发现代码高亮了，就可以在 vscode 运行 flutter 了。在 vscode 中运行flutter run即可在刚才启动的模拟器中运行应用，但是在 vscode 中不能热更新了，需要每次修改代码之后在命令行输入 r 才能在模拟器中看到效果，如果需要热更新，要使用 debug 。 打包Windows 打包 配置 app 图标 AndroidManifest.xml（配置 APP 的名称、图标和系统权限） 生成 keystore 配置 key 注册 生成 apk 在目录项目根目录/android/app/src/main/res/中设置图标文件 在目录项目根目录/android/app/src/main/AndroidManifest.xml中 12android: label = 'flutter_app'; //配置APP的名称，支持中文android: icon = '@mipmap/ic_launcher'; //APP图标的文件名称 通过D:\\Program\\Android\\&#39;Android Studio&#39;\\jre\\bin\\keytool -genkey -v -keystore D:\\key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key命令来生成 keystore，输入密码后，在 d 盘得到一个 key.jks 文件。D:\\Program\\Android\\&#39;Android Studio&#39;\\jre\\bin\\keytool安卓生成钥匙的地址，通过 flutter doctor -v 可以查询到Java binary at：D:\\Program\\Android\\&#39;Android Studio&#39;\\jre\\bin\\keytool，D:\\key.jks是生成钥匙的地址，生成好钥匙后，在android文件夹下创建一个名为 key.properties 的文件文件内容如下： 1234storePassword=123123 //输入上一步创建KEY时输入的 密钥库 密码keyPassword=123123 //输入上一步创建KEY时输入的 密钥 密码keyAlias=keystoreFile=D:\\key.jks //key.jks的存放路径 key 生成好后需要配置 build.gradle 文件，在项目目录的/android/app/build.gradle 文件，在 android{这一行前面,加入如下代码： 123def keystorePropertiesFile = rootProject.file(\"key.properties\")def keystoreProperties = new Properties()keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) 把如下代码进行替换: 12345buildTypes &#123; release &#123; signingConfig signingConfigs.debug &#125;&#125; 替换的代码： 12345678910111213signingConfigs &#123; release &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125;&#125;buildTypes &#123; release &#123; signingConfig signingConfigs.release &#125;&#125; 配置改好后运行flutter build apk就能够打包成 apk 在手机安装了","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://shawdanon.github.io/tags/笔记/"}]},{"title":"《学习 JavaScript 数据结构与算法》读书笔记","date":"2019-01-16T16:00:00.000Z","path":"read/learning-data-structures-and-algorithms/","text":"看完 react 的 diff 算法和 swagger 的数据结构，想温习波数据结构和算法。 2019-1-17 记数组 最简单的内存数据结构。 栈 一种顺序数据结构栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称做栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。 栈的创建123456789101112131415161718192021222324function Stack() &#123; var items = []; this.push = function(element) &#123; items.push(element); &#125;; //入栈 this.pop = function() &#123; return items.pop(); &#125;; //出栈，返回出站元素 this.peek = function() &#123; return items[items.length - 1]; &#125;; //返回栈顶元素 this.isEmpty = function() &#123; return items.length === 0; &#125;; //返回栈是否为空 this.clears = function() &#123; items = []; &#125;; //清空栈 this.sizes = function() &#123; return items.length; &#125;; //返回栈里元素个数 this.print = function() &#123; console.log(items.toString()); &#125;; //打印栈&#125; 从十进制到二进制1234567891011121314151617181920212223242526272829function divideBy2(decNumber) &#123; var remStack = new Stack(), rem, binaryString = ''; while (decNumber &gt; 0) &#123; rem = Math.floor(decNumber % 2); remStack.push(rem); decNumber = Math.floor(decNumber / 2); &#125; //取余数入栈 while (!remStack.isEmpty()) &#123; binaryString += remStack.pop().toString(); &#125; //出栈获得2进制数 return binaryString;&#125; //十进制转二进制function baseConverter(decNumber, base) &#123; var remStack = new Stack(), rem, baseString = '', digits = '0123456789ABCDEF'; while (decNumber &gt; 0) &#123; rem = Math.floor(decNumber % base); remStack.push(rem); decNumber = Math.floor(decNumber / base); &#125; while (!remStack.isEmpty()) &#123; baseString += digits[remStack.pop()]; &#125; return baseString;&#125; //十进制转任意进制（最多16进制） 其他实例：平衡圆括号和汉诺塔 队列 一种顺序数据结构队列是遵循 FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 创建队列123456789101112131415161718192021function Queue() &#123; var items = []; this.enqueue = function(element) &#123; itmes.push(element); &#125;; //向队列尾部添加一个（或多个）新的项 this.dequeue = function() &#123; return items.shift(); &#125;; //移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。 this.front = function() &#123; return items[0]; &#125;; //返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动。 this.isEmpty = function() &#123; return items.length === 0; &#125;; //如果队列中不包含任何元素，返回true，否则返回false。 this.sizes = function() &#123; return items.length; &#125;; //返回队列包含的元素个数，与数组的length属性类似。 this.print = function() &#123; console.log(items.toString()); &#125;;&#125; 优先队列12345678910111213141516171819202122232425function PriorityQueue() &#123; var items = []; function QueueElement(element, priority) &#123; this.element = element; this.priority = priority; &#125; this.enqueue = function(element, priority) &#123; var queueElement = new QueueElement(element, priority); if (this.isEmpty()) &#123; items.push(queueElement); &#125; else &#123; var added = false; for (var i = 0; i &lt; items.length; i++) &#123; if (queueElement.priority &lt; items[i].priority) &#123; items.splice(i, 0, queueElement); added = true; break; &#125; if (!added) &#123; items.push(queueElement); &#125; &#125; &#125; &#125;;&#125; //最小优先队列 循环队列——击鼓传花123456789101112131415function hotPotato(nameList, num) &#123; var queue = new Queue(); for (var i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]); &#125; var eliminated = ''; while (queue.size() &gt; 1) &#123; for (var i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); &#125; eliminated = queue.dequeue(); console.log(eliminated + '在击鼓传花游戏中被淘汰。'); &#125; return queue.dequeue();&#125; 链表 链表存储有序的元素集合,但不同于数组,链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。解决数组起点或中间插入或移除项的成本很高的问题 创建一个链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202function LinkedList() &#123; var Node = function(element) &#123; this.element = element; //添加到列表的值 this.next = null; //指向列表中下一个节点项的指针 &#125;; //要加入列表的项 var length = 0; //列表项的数量 var head = null; //第一个节点的引用 this.append = function(element) &#123; var node = new Node(element), current; if (head === null) &#123; head = node; //列表中第一个节点 &#125; else &#123; current = head; while (current.next) &#123; current = current.next; &#125; //循环链表,直到找到最后一项 current.next = node; //找到最后一项,将其next赋为node,建立链接 &#125; length++; //更新列表的长度 &#125;; //向列表尾部添加一个新的项。 this.insert = function(position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; var node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; //在第一个位置添加 node.next = current; head = node; &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; &#125; &#125;; //向列表的特定位置插入一个新的项。 this.removeAt = function(position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; var current = head, previous, index = 0; if (position === 0) &#123; head = current.next; //移除第一项 &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; previous.next = current.next; //重点：将previous与current的下一项链接起来:跳过current,从而移除它 &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125;; //从列表的特定位置移除一项。 this.remove = function(element) &#123; var current = head, previous, index = 0; while (current) &#123; if (element === current.element) &#123; if (index === 0) &#123; head = current.next; //移除第一项 &#125; else &#123; previous = current; current = current.next; previous.next = current.next; //重点：将previous与current的下一项链接起来:跳过current,从而移除它 &#125; &#125; index++; &#125; &#125;; //从列表中移除一项。 this.indexOf = function(element) &#123; var current = head, index = -1; while (current) &#123; if (element === current.element) &#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125;; //返回元素在列表中的索引。如果列表中没有该元素则返回 -1 。 this.isEmpty = function() &#123; return length === 0; &#125;; //如果链表中不包含任何元素,返回 true ,如果链表长度大于0则返回 false 。 this.size = function() &#123; return length; &#125;; //返回链表包含的元素个数。与数组的 length 属性类似。 this.toString = function() &#123; var current = head, string = ''; while (current) &#123; // string = current.element; //书中写法，这样只能获得最后一项的字符串 string += current.next ? `$&#123;current.element&#125;,` : current.element; current = current.next; &#125; return string; &#125;; //由于列表项使用了 Node 类,就需要重写继承自JavaScript对象默认的toString 方法,让其只输出元素的值。 this.print = function() &#123; console.log(head); console.log(length); &#125;; //辅助查看链表&#125; //单项链表function DoublyLinkedList() &#123; var Node = function(element) &#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; var length = 0; var head = null; var tail = null; //新增的 //这里是方法 this.insert = function(position, element) &#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length) &#123; var node = new Node(element), current = head, previous, index = 0; if (position === 0) &#123; if (!head) &#123; head = node; tail = node; &#125; else &#123; node.next = current; current.prev = node; head = node; &#125; &#125; else if (position === length) &#123; current = tail; current.next = node; node.prev = current; tail = node; &#125; else &#123; while (index++ &lt; position) &#123; previous = current; current = current.next; &#125; node.next = current; previous.next = node; current.prev = node; node.prev = previous; &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; &#125; &#125;; this.removeAt = function(position) &#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length) &#123; var current = head, previous, index = 0; //移除第一项 if (position === 0) &#123; head = current.next; // &#123;1&#125; //如果只有一项，更新tail //新增的 if (length === 1) &#123; // &#123;2&#125; tail = null; &#125; else &#123; head.prev = null; // &#123;3&#125; &#125; &#125; else if (position === length - 1) &#123; //最后一项 //新增的 current = tail; // &#123;4&#125; tail = current.prev; tail.next = null; &#125; else &#123; while (index++ &lt; position) &#123; // &#123;5&#125; previous = current; current = current.next; &#125; //将previous与current的下一项链接起来——跳过current previous.next = current.next; // &#123;6&#125; current.next.prev = previous; //新增的 &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125;;&#125; //双向链表 集合 一种非顺序数据结构集合是由一组无序且唯一（即不能重复）的项组成的。集合中的对象列表用{}（大括号）包围。 创建一个集合12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function Set() &#123; var items = &#123;&#125;; this.add = function(value) &#123; if (!this.has(value)) &#123; items[value] = value; return true; &#125; return false; &#125;; //向集合添加一个新的项。 this.remove = function(value) &#123; if (this.has(value)) &#123; delete items[value]; return true; &#125; return false; &#125;; //从集合移除一个值。 this.has = function(value) &#123; // return value in items; //老办法 return items.hasOwnProperty(value); &#125;; //如果值在集合中，返回true，否则返回false。 this.clear = function() &#123; items = &#123;&#125;; &#125;; //移除集合中的所有项。 this.size = function() &#123; // var count = 0; // for (var prop in items) &#123; // if (items.hasOwnProperty(prop)) &#123; // ++count; // &#125; // &#125; // return count; return Object.keys(items).length; &#125;; //返回集合所包含元素的数量。与数组的length属性类似。 this.values = function() &#123; return Object.keys(items); &#125;; //返回一个包含集合中所有值的数组。 this.union = function(otherSet) &#123; var unionSet = new Set(); var values = this.values(); for (var i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for (var i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; return unionSet; &#125;; //并集 this.intersection = function(otherSet) &#123; var intersectionSet = new Set(); var values = this.values(); for (var i = 0; i &lt; values.length; i++) &#123; if (otherSet.has(values[i])) &#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet; &#125;; //交集 this.difference = function(otherSet) &#123; var differenceSet = new Set(); var values = this.values(); for (var i = 0; i &lt; values.length; i++) &#123; if (!otherSet.has(values[i])) &#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet; &#125;; //差集 this.subset = function(otherSet) &#123; if (this.size() &gt; otherSet.size()) &#123; return false; &#125; else &#123; var values = this.values(); for (var i = 0; i &lt; values.length; i++) &#123; if (!otherSet.has(values[i])) &#123; return false; &#125; &#125; return true; &#125; &#125;;&#125; //子集 字典和散列表字典 一种非顺序数据结构在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。 创建一个字典12345678910111213141516171819202122232425262728293031function Dictionary() &#123; var items = &#123;&#125;; function set(key, value) &#123; items[key] = value; &#125; //向字典中添加新元素。 this.remove = function(key) &#123; if (this.has(key)) &#123; delete items[key]; return true; &#125; return false; &#125;; //通过使用键值来从字典中移除键值对应的数据值。 this.has = function(key) &#123; return key in items; &#125;; //如果某个键值存在于这个字典中，则返回true，反之则返回false。 this.get = function(key) &#123; return this.has(key) ? items[key] : undefined; &#125;; //通过键值查找特定的数值并返回。 this.clear = function() &#123;&#125;; //将这个字典中的所有元素全部删除。 this.size = function() &#123;&#125;; //返回字典所包含元素的数量。与数组的length属性类似。 this.keys = function() &#123;&#125;; //将字典所包含的所有键名以数组形式返回。 this.values = function() &#123; var values = []; for (var k in items) &#123; if (this.has(k)) &#123; values.push(items[k]); &#125; &#125; return values; &#125;; //将字典所包含的所有数值以数组形式返回。&#125; 散列表 一种非顺序数据结构散列表就是通过散列算法将字典的键转化成对应下标值取得键对应的值。散列算法的作用是尽可能快地在数据结构中找到一个值。 创建一个散列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148function HashTable() &#123; var table = []; var loseloseHashCode = function(key) &#123; var hash = 0; for (var i = 0; i &lt; key.length; i++) &#123; hash += key.charCodeAt(i); &#125; return hash % 37; &#125;; //散列函数 this.put = function(key, value) &#123; var position = loseloseHashCode(key); console.log(position + ' - ' + key); table[position] = value; &#125;; //向散列表增加一个新的项(也能更新散列表) this.remove = function(key) &#123; table[loseloseHashCode(key)] = undefined; &#125;; //根据键值从散列表中移除值。 this.get = function(key) &#123; return table[loseloseHashCode(key)]; &#125;; //返回根据键值检索到的特定的值。&#125; //带冲突的散列表function HashTable１() &#123; var table = []; var loseloseHashCode = function(key) &#123; var hash = 0; for (var i = 0; i &lt; key.length; i++) &#123; hash += key.charCodeAt(i); &#125; return hash % 37; &#125;; //散列函数 var ValuePair = function(key, value) &#123; this.key = key; this.value = value; this.toString = function() &#123; return '[' + this.key + ' - ' + this.value + ']'; &#125;; &#125;; this.put = function(key, value) &#123; var position = loseloseHashCode(key); if (table[position] == undefined) &#123; table[position] = new LinkedList(); //前面的链表 &#125; table[position].append(new ValuePair(key, value)); &#125;; //向散列表增加一个新的项(也能更新散列表) this.remove = function(key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; var current = table[position].getHead(); while (current.next) &#123; if (current.element.key === key) &#123; table[position].remove(current.element); if (table[position].isEmpty()) &#123; table[position] = undefined; &#125; return true; &#125; current = current.next; &#125; // 检查是否为第一个或最后一个元素 if (current.element.key === key) &#123; table[position].remove(current.element); if (table[position].isEmpty()) &#123; table[position] = undefined; &#125; return true; &#125; &#125; return false; &#125;; //根据键值从散列表中移除值。 this.get = function(key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; var current = table[position].getHead(); while (current.next) &#123; if (current.element.key === key) &#123; return current.element.value; &#125; current = current.next; &#125; //检查元素在链表第一个或最后一个节点的情况 if (current.element.key === key) &#123; return current.element.value; &#125; &#125; return undefined; &#125;; //返回根据键值检索到的特定的值。&#125; //分离链接解决散列表冲突function HashTable２() &#123; var table = []; var loseloseHashCode = function(key) &#123; var hash = 0; for (var i = 0; i &lt; key.length; i++) &#123; hash += key.charCodeAt(i); &#125; return hash % 37; &#125;; //散列函数 this.put = function(key, value) &#123; var position = loseloseHashCode(key); if (table[position] == undefined) &#123; table[position] = new ValuePair(key, value); &#125; else &#123; var index = ++position; while (table[index] != undefined) &#123; index++; &#125; table[index] = new ValuePair(key, value); &#125; &#125;; //向散列表增加一个新的项(也能更新散列表) this.remove = function(key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; if (table[position].key === key) &#123; return table[position].value; &#125; else &#123; var index = ++position; while (table[index] === undefined || table[index].key !== key) &#123; index++; &#125; table[index] = undefined; &#125; &#125; return undefined; &#125;; //根据键值从散列表中移除值。 this.get = function(key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined) &#123; if (table[position].key === key) &#123; return table[position].value; &#125; else &#123; var index = ++position; while (table[index] === undefined || table[index].key !== key) &#123; index++; &#125; if (table[index].key === key) &#123; return table[index].value; &#125; &#125; &#125; return undefined; &#125;; //返回根据键值检索到的特定的值。&#125; //线性探查解决散列表冲突var djb2HashCode = function(key) &#123; var hash = 5381; for (var i = 0; i &lt; key.length; i++) &#123; hash = hash * 33 + key.charCodeAt(i); &#125; return hash % 1013;&#125;; //更好的散列函数 树 一种非顺序数据结构它对于存储需要快速查找的数据非常有用。 创建 BinarySearchTree 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135function BinarySearchTree() &#123; var Node = function(key) &#123; this.key = key; this.left = null; this.right = null; &#125;; var root = null; var insertNode = function(node, newNode) &#123; if (newNode.key &lt; node.key) &#123; if (node.left === null) &#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null) &#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;; this.insert = function(key) &#123; var newNode = new Node(key); if (root === null) &#123; root = newNode; &#125; else &#123; insertNode(root, newNode); &#125; &#125;; //向树中插入一个新的键。 var searchNode = function(node, key) &#123; if (node === null) &#123; return false; &#125; if (key &lt; node.key) &#123; return searchNode(node.left, key); &#125; else if (key &gt; node.key) &#123; return searchNode(node.right, key); &#125; else &#123; return true; &#125; &#125;; this.search = function(key) &#123; return searchNode(root, key); &#125;; //在树中查找一个键,如果节点存在,则返回 true ;如果不存在,则返回false 。 var inOrderTraverseNode = function(node, callback) &#123; if (node !== null) &#123; inOrderTraverseNode(node.left, callback); callback(node.key); inOrderTraverseNode(node.right, callback); &#125; &#125;; this.inOrderTraverse = function(callback) &#123; inOrderTraverseNode(root, callback); &#125;; //通过中序遍历方式遍历所有节点。 var preOrderTraverseNode = function(node, callback) &#123; if (node !== null) &#123; callback(node.key); preOrderTraverseNode(node.left, callback); preOrderTraverseNode(node.right, callback); &#125; &#125;; this.preOrderTraverse = function() &#123; preOrderTraverseNode(root, callback); &#125;; //通过先序遍历方式遍历所有节点。 var postOrderTraverseNode = function(node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback); postOrderTraverseNode(node.right, callback); callback(node.key); &#125; &#125;; this.postOrderTraverse = function() &#123; postOrderTraverseNode(root, callback); &#125;; //通过后序遍历方式遍历所有节点。 var minNode = function(node) &#123; if (node) &#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left; &#125; return node.key; &#125; return null; &#125;; this.min = function() &#123; return minNode(root); &#125;; //返回树中最小的值/键。 var maxNode = function(node) &#123; if (node) &#123; while (node &amp;&amp; node.right !== null) &#123; node = node.right; &#125; return node.key; &#125; return null; &#125;; this.max = function() &#123; return maxNode(root); &#125;; //返回树中最大的值/键。 var removeNode = function(node, key) &#123; if (node === null) &#123; return null; &#125; if (key &lt; node.key) &#123; node.left = removeNode(node.left, key); return node; &#125; else if (key &gt; node.key) &#123; node.right = removeNode(node.right, key); return node; &#125; else &#123; //键等于node.key //第一种情况——一个叶节点 if (node.left === null &amp;&amp; node.right === null) &#123; node = null; return node; &#125; //第二种情况——一个只有一个子节点的节点 if (node.left === null) &#123; node = node.right; return node; &#125; else if (node.right === null) &#123; node = node.left; return node; &#125; //第三种情况——一个有两个子节点的节点 var aux = findMinNode(node.right); node.key = aux.key; node.right = removeNode(node.right, aux.key); return node; &#125; &#125;; this.remove = function(key) &#123; root = removeNode(root, key); &#125;; //从树中移除某个键。&#125; 图 一种非线性数据结构。图是网络结构的抽象模型。 创建图类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144function Graph() &#123; var vertices = []; var adjList = new Dictionary(); this.addVertex = function(v) &#123; vertices.push(v); adjList.set(v, []); &#125;; this.addEdge = function(v, w) &#123; adjList.get(v).push(w); adjList.get(w).push(v); &#125;; //添加元素 this.toString = function() &#123; var s = ''; for (var i = 0; i &lt; vertices.length; i++) &#123; s += vertices[i] + ' -&gt; '; var neighbors = adjList.get(vertices[i]); for (var j = 0; j &lt; neighbors.length; j++) &#123; s += neighbors[j] + ' '; &#125; s += '\\n'; &#125; return s; &#125;; //显示图 var initializeColor = function() &#123; var color = []; for (var i = 0; i &lt; vertices.length; i++) &#123; color[vertices[i]] = 'white'; &#125; return color; &#125;; this.bfs = function(v, callback) &#123; var color = initializeColor(), queue = new Queue(); queue.enqueue(v); while (!queue.isEmpty()) &#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (var i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; color[w] = 'grey'; queue.enqueue(w); &#125; &#125; color[u] = 'black'; if (callback) &#123; callback(u); &#125; &#125; &#125;; //广度优先搜索 this.BFS = function(v) &#123; var color = initializeColor(), queue = new Queue(), d = [], pred = []; queue.enqueue(v); for (var i = 0; i &lt; vertices.length; i++) &#123; d[vertices[i]] = 0; pred[vertices[i]] = null; &#125; while (!queue.isEmpty()) &#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; color[w] = 'grey'; d[w] = d[u] + 1; pred[w] = u; queue.enqueue(w); &#125; &#125; color[u] = 'black'; &#125; return &#123; distances: d, predecessors: pred &#125;; &#125;; //优化广度优先搜索 this.dfs = function(callback) &#123; var color = initializeColor(); for (var i = 0; i &lt; vertices.length; i++) &#123; if (color[vertices[i]] === 'white') &#123; dfsVisit(vertices[i], color, callback); &#125; &#125; &#125;; var dfsVisit = function(u, color, callback) &#123; color[u] = 'grey'; if (callback) &#123; callback(u); &#125; var neighbors = adjList.get(u); for (var i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; dfsVisit(w, color, callback); &#125; &#125; color[u] = 'black'; &#125;; //深度优先搜索 var time = 0; var DFSVisit = function(u, color, d, f, p) &#123; console.log('discovered ' + u); color[u] = 'grey'; d[u] = ++time; var neighbors = adjList.get(u); for (var i = 0; i &lt; neighbors.length; i++) &#123; var w = neighbors[i]; if (color[w] === 'white') &#123; p[w] = u; DFSVisit(w, color, d, f, p); &#125; &#125; color[u] = 'black'; f[u] = ++time; console.log('explored ' + u); &#125;; this.DFS = function() &#123; var color = initializeColor(), d = [], f = [], p = []; time = 0; for (var i = 0; i &lt; vertices.length; i++) &#123; f[vertices[i]] = 0; d[vertices[i]] = 0; p[vertices[i]] = null; &#125; for (i = 0; i &lt; vertices.length; i++) &#123; if (color[vertices[i]] === 'white') &#123; DFSVisit(vertices[i], color, d, f, p); &#125; &#125; return &#123; discovery: d, finished: f, predecessors: p &#125;; &#125;; //优化深度优先搜索&#125; 排序和搜索算法 排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序搜索算法：顺序搜索、二分搜索 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150function ArrayList() &#123; var array = []; this.insert = function(item) &#123; array.push(item); &#125;; //插入元素 this.toString = function() &#123; return array.join(); &#125;; //返回字符串 var swap = function(index1, index2) &#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux; &#125;; this.bubbleSort = function() &#123; var length = array.length; for (var i = 0; i &lt; length; i++) &#123; // for (var j = 0; j &lt; length - 1; j++) &#123; //未改进的排序 for (var j = 0; j &lt; length - 1 - i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; swap(j, j + 1); &#125; &#125; &#125; &#125;; //冒泡排序（比较相邻元素，前一个大于后一个则交换位置，最终得到升序数组） this.selectionSort = function() &#123; var length = array.length, indexMin; for (var i = 0; i &lt; length - 1; i++) &#123; indexMin = i; for (var j = i; j &lt; length; j++) &#123; if (array[indexMin] &gt; array[j]) &#123; indexMin = j; &#125; &#125; if (i !== indexMin) &#123; swap(i, indexMin); &#125; &#125; &#125;; //选择排序（比较数组类数据，最小的一项与当前循环轮数项交换，最终得到升序数组） this.insertionSort = function() &#123; var length = array.length, j, temp; for (var i = 1; i &lt; length; i++) &#123; j = i; temp = array[i]; while (j &gt; 0 &amp;&amp; array[j - 1] &gt; temp) &#123; array[j] = array[j - 1]; j--; &#125; array[j] = temp; &#125; &#125;; //插入排序（插入排序每次排一个数组项，以此方式构建最后的排序数组） var merge = function(left, right) &#123; var result = [], il = 0, ir = 0; while (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il++]); &#125; else &#123; result.push(right[ir++]); &#125; &#125; while (il &lt; left.length) &#123; result.push(left[il++]); &#125; while (ir &lt; right.length) &#123; result.push(right[ir++]); &#125; return result; &#125;; var mergeSortRec = function(array) &#123; var length = array.length; if (length === 1) &#123; return array; &#125; var mid = Math.floor(length / 2), left = array.slice(0, mid), right = array.slice(mid, length); return merge(mergeSortRec(left), mergeSortRec(right)); &#125;; this.mergeSort = function() &#123; array = mergeSortRec(array); &#125;; //归并排序（打散后重新组合） var swapQuickStort = function(array, index1, index2) &#123; var aux = array[index1]; array[index1] = array[index2]; array[index2] = aux; &#125;; var partition = function(array, left, right) &#123; var pivot = array[Math.floor((right + left) / 2)], i = left, j = right; while (i &lt;= j) &#123; while (array[i] &lt; pivot) &#123; i++; &#125; while (array[j] &gt; pivot) &#123; j--; &#125; if (i &lt;= j) &#123; swapQuickStort(array, i, j); i++; j--; &#125; &#125; return i; &#125;; var quick = function(array, left, right) &#123; var index; if (array.length &gt; 1) &#123; index = partition(array, left, right); if (left &lt; index - 1) &#123; quick(array, left, index - 1); &#125; if (index &lt; right) &#123; quick(array, index, right); &#125; &#125; &#125;; this.quickSort = function() &#123; quick(array, 0, array.length - 1); &#125;; //快速排序 this.sequentialSearch = function(item) &#123; for (var i = 0; i &lt; array.length; i++) &#123; if (item === array[i]) return i; &#125; return -1; &#125;; //顺序搜索 this.binarySearch = function(item) &#123; this.quickSort(); var low = 0, high = array.length - 1, mid, element; while (low &lt;= high) &#123; mid = Math.floor((low + high) / 2); element = array[mid]; if (element &lt; item) &#123; low = mid + 1; &#125; else if (element &gt; item) &#123; high = mid - 1; &#125; else &#123; return mid; &#125; &#125; return -1; &#125;; //二分搜索&#125; 算法补充知识递归 递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。通常涉及函数调用自身。 动态规划 动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。 用动态规划解决问题时，要遵循三个重要步骤： 定义子问题； 实现要反复执行而解决子问题的部分（这一步要参考前一节讨论的递归的步骤）； 识别并求解出边界条件。 能用动态规划解决的一些著名的问题如下: 背包问题：给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。 矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。 硬币找零：给出面额为 d1…dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。 图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。 贪心算法 贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。 大 O 表示法 描述算法的性能和复杂程度。O(1)：常数的O(log(n))：对数的O((log(n))c)：对数多项式的O(n)：线性的O($n^2$)：二次的O($n^c$)：多项式的O($c^n$)：指数的","tags":[{"name":"阅读笔记","slug":"阅读笔记","permalink":"https://shawdanon.github.io/tags/阅读笔记/"}]},{"title":"前端开发人员面试问题","date":"2018-10-04T16:00:00.000Z","path":"collection/front-end-Interview/","text":"前端面试… 前端工作面试问题常见问题 你在昨天/本周学到了什么？ 编写代码的哪些方面能够使你兴奋或感兴趣？ 你最近遇到过什么技术挑战？你是如何解决的？ 在制作一个网页应用或网站的过程中，你是如何考虑其 UI、安全性、高性能、SEO、可维护性以及技术因素的？ 请谈谈你喜欢的开发环境。 你最熟悉哪一套版本控制系统？ 你能描述当你制作一个网页的工作流程吗？ 假若你有 5 个不同的样式文件 (stylesheets), 整合进网站的最好方式是? 你能描述渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 之间的不同吗? 你如何对网站的文件和资源进行优化？ 浏览器同一时间可以从一个域名下载多少资源？ 有什么例外吗？ 请说出三种减少页面加载时间的方法。(加载时间指感知的时间或者实际加载时间) 如果你参与到一个项目中，发现他们使用 Tab 来缩进代码，但是你喜欢空格，你会怎么做？ 请写一个简单的幻灯效果页面。 如果今年你打算熟练掌握一项新技术，那会是什么？ 请谈谈你对网页标准和标准制定机构重要性的理解。 什么是 FOUC (无样式内容闪烁)？你如何来避免 FOUC？ 请解释什么是 ARIA 和屏幕阅读器 (screenreaders)，以及如何使网站实现无障碍访问 (accessible)。 请解释 CSS 动画和 JavaScript 动画的优缺点。 什么是跨域资源共享 (CORS)？它用于解决什么问题？ HTML 相关问题 doctype(文档类型) 的作用是什么？ 浏览器标准模式 (standards mode) 、几乎标准模式（almost standards mode）和怪异模式 (quirks mode) 之间的区别是什么？ HTML 和 XHTML 有什么区别？ 如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？ 如果网页内容需要支持多语言，你会怎么做？ 在设计和开发多语言网站时，有哪些问题你必须要考虑？ 使用 data- 属性的好处是什么？ 如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些？ 请描述 cookies、sessionStorage 和 localStorage 的区别。 请解释 &lt;script&gt;、&lt;script async&gt; 和 &lt;script defer&gt; 的区别。 为什么通常推荐将 CSS &lt;link&gt; 放置在 &lt;head&gt;&lt;/head&gt; 之间，而将 JS &lt;script&gt; 放置在 &lt;/body&gt; 之前？你知道有哪些例外吗？ 什么是渐进式渲染 (progressive rendering)？ 你用过哪些不同的 HTML 模板语言？ CSS 相关问题 CSS 中类 (classes) 和 ID 的区别。 请问 “resetting” 和 “normalizing” CSS 之间的区别？你会如何选择，为什么？ 请解释浮动 (Floats) 及其工作原理。 描述z-index和叠加上下文是如何形成的。 请描述 BFC(Block Formatting Context) 及其如何工作。 列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。 请解释 CSS sprites，以及你要如何在页面或网站中实现它。 你最喜欢的图片替换方法是什么，你如何选择使用。 你会如何解决特定浏览器的样式问题？ 如何为有功能限制的浏览器提供网页？ 你会使用哪些技术和处理方法？ 有哪些的隐藏内容的方法 (如果同时还要保证屏幕阅读器可用呢)？ 你用过栅格系统 (grid system) 吗？如果使用过，你最喜欢哪种？ 你用过媒体查询，或针对移动端的布局/CSS 吗？ 你熟悉 SVG 样式的书写吗？ 如何优化网页的打印样式？ 在书写高效 CSS 时会有哪些问题需要考虑？ 使用 CSS 预处理器的优缺点有哪些？ 请描述你曾经使用过的 CSS 预处理器的优缺点。 如果设计中使用了非标准的字体，你该如何去实现？ 请解释浏览器是如何判断元素是否匹配某个 CSS 选择器？ 请描述伪元素 (pseudo-elements) 及其用途。 请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。 请解释 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？ 请罗列出你所知道的 display 属性的全部值 请解释 inline 和 inline-block 的区别？ 请解释 relative、fixed、absolute 和 static 元素的区别 CSS 中字母 ‘C’ 的意思是叠层 (Cascading)。请问在确定样式的过程中优先级是如何决定的 (请举例)？如何有效使用此系统？ 你在开发或生产环境中使用过哪些 CSS 框架？你觉得应该如何改善他们？ 请问你有尝试过 CSS Flexbox 或者 Grid 标准规格吗？ 为什么响应式设计 (responsive design) 和自适应设计 (adaptive design) 不同？ 你有兼容 retina 屏幕的经历吗？如果有，在什么地方使用了何种技术？ 请问为何要使用 translate() 而非 absolute positioning，或反之的理由？为什么？ JS 相关问题 请解释事件代理 (event delegation)。 请解释 JavaScript 中 this 是如何工作的。 请解释原型继承 (prototypal inheritance) 的原理。 你怎么看 AMD vs. CommonJS？ 请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式)：function foo(){ }();. 要做哪些改动使它变成 IIFE? 描述以下变量的区别：null，undefined 或 undeclared？ 该如何检测它们？ 什么是闭包 (closure)，如何使用它，为什么要使用它？ 请举出一个匿名函数的典型用例？ 你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？ 请指出 JavaScript 宿主对象 (host objects) 和原生对象 (native objects) 的区别？ 请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()？ .call 和 .apply 的区别是什么？ 请解释 Function.prototype.bind？ 在什么时候你会使用 document.write()？ 请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别？ 请尽可能详尽的解释 Ajax 的工作原理。 使用 Ajax 都有哪些优劣？ 请解释 JSONP 的工作原理，以及它为什么不是真正的 Ajax。 你使用过 JavaScript 模板系统吗？ 如有使用过，请谈谈你都使用过哪些库？ 请解释变量声明提升 (hoisting)。 请描述事件冒泡机制 (event bubbling)。 “attribute” 和 “property” 的区别是什么？ 为什么扩展 JavaScript 内置对象不是好的做法？ 请指出 document load 和 document DOMContentLoaded 两个事件的区别。 == 和 === 有什么不同？ 请解释 JavaScript 的同源策略 (same-origin policy)。 如何实现下列代码： 1[1, 2, 3, 4, 5].duplicator(); // [1,2,3,4,5,1,2,3,4,5] 什么是三元表达式 (Ternary expression)？“三元 (Ternary)” 表示什么意思？ 什么是 &quot;use strict&quot;; ? 使用它的好处和坏处分别是什么？ 请实现一个遍历至 100 的 for loop 循环，在能被 3 整除时输出 “fizz”，在能被 5 整除时输出 “buzz”，在能同时被 3 和 5 整除时输出 “fizzbuzz”。 为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？ 为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？ 请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。 你使用过 Promises 及其 polyfills 吗? 请写出 Promise 的基本用法（ES6）。 使用 Promises 而非回调 (callbacks) 优缺点是什么？ 使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？ 你使用哪些工具和技术来调试 JavaScript 代码？ 你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？ 请解释可变 (mutable) 和不变 (immutable) 对象的区别。 请举出 JavaScript 中一个不变性对象 (immutable object) 的例子？ 不变性 (immutability) 有哪些优缺点？ 如何用你自己的代码来实现不变性 (immutability)？ 请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别。 什么是事件循环 (event loop)？ 请问调用栈 (call stack) 和任务队列 (task queue) 的区别是什么？ 解释 function foo() {} 与 var foo = function() {} 用法的区别 测试相关问题 对代码进行测试的有什么优缺点？ 你会用什么工具测试你的代码功能？ 单元测试与功能/集成测试的区别是什么？ 代码风格 linting 工具的作用是什么？ 效能相关问题 你会用什么工具来查找代码中的性能问题？ 你会用什么方式来增强网站的页面滚动效能？ 请解释 layout、painting 和 compositing 的区别。 网络相关问题 为什么传统上利用多个域名来提供网站资源会更有效？ 请尽可能完整得描述从输入 URL 到整个网页加载完毕及显示在屏幕上的整个流程。 Long-Polling、Websockets 和 Server-Sent Event 之间有什么区别？ 请描述以下 request 和 response headers： Diff. between Expires, Date, Age and If-Modified-… Do Not Track Cache-Control Transfer-Encoding ETag X-Frame-Options 什么是 HTTP method？请罗列出你所知道的所有 HTTP method，并给出解释。 请解释 HTTP status 301 与 302 的区别？ 代码相关的问题问题：foo的值是什么？ 1var foo = 10 + '20'; 问题：如何实现以下函数？ 12add(2, 5); // 7add(2)(5); // 7 问题：下面的语句的返回值是什么？ 1234\"i'm a lasagna hog\" .split('') .reverse() .join(''); 问题：window.foo的值是什么？ 1window.foo || (window.foo = 'bar'); 问题：下面两个 alert 的结果是什么？ 123456var foo = 'Hello';(function() &#123; var bar = ' World'; alert(foo + bar);&#125;)();alert(foo + bar); 问题：foo.length的值是什么？ 123var foo = [];foo.push(1);foo.push(2); 问题：foo.x的值是什么？ 123var foo = &#123; n: 1 &#125;;var bar = foo;foo.x = foo = &#123; n: 2 &#125;; 问题：下面代码的输出是什么？ 12345console.log('one');setTimeout(function() &#123; console.log('two');&#125;, 0);console.log('three'); 趣味问题 你最近写过什么的很酷的项目吗？ 在你使用的开发工具中，最喜欢哪些方面？ 谁使你踏足了前端开发领域？ 你有什么业余项目吗？是哪种类型的？ 你最爱的 IE 特性是什么？ 你对咖啡有没有什么喜好？ 原文链接原文链接","tags":[{"name":"面试","slug":"面试","permalink":"https://shawdanon.github.io/tags/面试/"}]},{"title":"记一次小程序开发","date":"2018-09-27T16:00:00.000Z","path":"2018/first-mini-program/","text":"第一次小程序开发。 统计开始时间：2018.8.20开发结束时间：2018.9.21测试结束时间：2018.9.28页面组件统计:32 个页面组件公共组件统计:11 个公共组件实际工作时间(包括加班):开发 271.5 小时，测试 67.5 小时 背景第一次做手机端 APP，第一次使用小程序开发，第一次使用数据驱动做公司项目（原来用的 jQuery 进行 dom 操作）。 需求按照 APP（商城类）开发小程序 详细经历第一周 像素单位用 rpx,2rpx ＝ 1px。 flex 垂直布局 margin-right 失效。 第二周 问题：Java 后端返回 id 为 lang 类型，前端获取会丢失精度。 创建了控制器文件夹，用来放与后端交互的接口(也不知道也没用)。 用 promise 封装了常用的请求方法，做了统一错误处理，后台异常处理。 第三周 发现有很多表单页面相似，于是封装了一个表单页面组件，通过给组件传入页面元素配置和验证规则实现复用。 创建测试页面通过按钮的方式来测试后端接口是否有问题。 移动端分页 第四周 图片上传踩坑：刚开始：因为不能使用原生，通过查文档使用 wx.chooseImage 选择图片获取临时路径、把临时路径作为一个请求的 url，把数据返回格式设置成 arraybuffer 可以拿到图片 base64 格式提交给后端，这个方法在微信模拟器没什么问题，在真机上就会报错了。解决方案：wx.chooseImage 选择图片获取临时路径，readFile()读取文件获取 base64 格式编码。 支付接口踩坑：刚开始：通过 wx.login()拿到 code，在访问腾讯地址拿到 openid，然后传给后端拿到掉支付接口需要的字段，最后掉起接口 wx.requestPayment()弹出微信支付界面，通过回调判断支付是否成功给后端反馈，这个方法有一个步骤出问题了，在微信开发工具中开启忽略验证不会有问题，上线了就会访问不了腾讯地址获取 openid，因为腾讯默认这个地址不合法。解决方案：获取 oppenid 这一步放到后端实现就可以解决。 需要改进的地方关于错误处理 后端返回错误码和提示信息统一处理（已有，通过弹窗形式提示错误信息），应该换种形式来区分前端写的提示信息。","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"总结","slug":"总结","permalink":"https://shawdanon.github.io/tags/总结/"}]},{"title":"阅读","date":"2018-09-12T16:00:00.000Z","path":"arrangement/read/","text":"记录我的阅读,欢迎小伙伴来交换电子书… 书单20191、《高难度谈话》2、《聪明的投资者》3、《创新者》4、《经济学通识课》5、《奇特的一生》6、《学会提问—批判性思维指南》7、《人性的弱点》8、《少有人走的路》9、《社会心理学（第 8 版）》10、《影响力》11、《谈谈方法》12、《黑客与画家》13、《如何阅读一本书》14、《拖延心理学》15、《浪潮之巅》16、《创业维艰》 巴菲特推荐的书1、《聪明的投资者》——格雷厄姆著2、《怎样选择成长股》——费舍尔著3、《证券分析》——格雷厄姆 多德著4、《杰克·韦尔奇自传》——本杰明·格雷厄姆5、《学以致富》——彼得·林奇著6、《赢》——杰克·韦尔奇著7、《穷光蛋查理年鉴》（富兰克林著）8、《探索智慧:从达尔文到芒格》——Reter Bevelin 著9、《客户的游艇在哪里》——Fred Schweb 著10、《巴菲特致股东的信：股份公司教程》 已读2019 年1、《学习 JavaScript 数据结构与算法》2、《前端面试指南》3、《富爸爸 财务自由之路》 2018 年1、《非暴力沟通》2、《人类简史》3、《JavaScript 高级程序设计》(第三版)4、《谈话的力量》5、《穷爸爸富爸爸》6、《小狗钱钱》7、《番茄工作法》8、《工作五年，决定你一生的财富》9、《CSS 权威指南》(第三版)10、《ECMAScript 6 入门》11、《高效能人士的七个习惯》12、《图解 HTTP》13、《Node.js 高级编程》 2017 年1、《Web 全栈工程师的自我修养》2、《腾讯传》3、《从零到一》4、《羊皮卷》5、《平凡的世界》6、《只是为了好玩：Linux 之父林纳斯自传》","tags":[{"name":"整理","slug":"整理","permalink":"https://shawdanon.github.io/tags/整理/"}]},{"title":"VSCode","date":"2018-08-11T16:00:00.000Z","path":"2018/VSCode/","text":"工欲善其事必先利其器… 常用插件Add jsdoc comments(快速添加 jsdoc 插件)Atom One Dark Theme(Atom 颜色主题)Bracket Pair Colorizer(每一对括号用不同颜色区别)Chinese (Simplified) Language Pack for Visual Studio Code(简体中文)cssrem(px 转 rem)Debugger for Chrome(在编辑器里面 debug)Easy LESS（less 文件转 css）ES7 React/Redux/GraphQL/React-Native snippets（react 常用代码片段）ESLint(代码检查)Git History(图形化 git 历史记录)GitLens — Git supercharged(git 管理利器)HTML CSS Support(HTML 中 CSS 智能提示)Markdown All in One(Markdown 快捷输入)markdownlint(Markdown 检查)open in browser(通过浏览器运行 HTML)Path Intellisense(路径智能提示)Power Mode（输入代码很酷炫的效果）Prettier - Code formatter(代码格式化)Settings Sync(多台电脑同步配置)Sublime Text Keymap and Settings Importer(sublime 键位设置)Vetur(vue 提示扩展)vscode-icons(图标主题) 用户设置Commonly Used(常用)1234567891011121314\"editor.fontSize\": 13, //以像素为单位控制字号\"editor.fontFamily\": \"Consolas\", //控制字体系列\"editor.tabSize\": 2, //一个制表符等于的空格数\"editor.renderWhitespace\": \"none\",//控制编辑器在空白字符上显示特殊符号的方式。\"editor.multiCursorModifier\": \"ctrlCmd\", //在通过鼠标添加多个光标时使用的修改键。\"files.exclude\": &#123;\"**/.idea\": true,\"**/yarn.lock\": true,\"**/tmp\": true&#125;, //配置 glob 模式以在搜索中排除文件和文件夹。例如，文件资源管理器根据此设置决定文件或文件夹的显示和隐藏。\"files.associations\": &#123;\"_.vue\": \"vue\",\"_.wxss\": \"css\"&#125;, //配置语言的文件关联(如: \"*.extension\": \"html\")。这些关联的优先级高于已安装语言的默认关联。 整个配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&#123; /*编辑器*/ //每行字数 防止&#123;&#125; []换行 \"editor.cursorBlinking\": \"smooth\", //控制字体系列 // \"editor.fontFamily\": \"Consolas\", //以像素为单位控制字号 \"editor.fontSize\": 15, //控制编辑器是否应自动设置粘贴内容的格式。 \"editor.formatOnPaste\": true, //保存时设置文件的格式。格式化程序必须可用，不能自动保存文件，并且不能关闭编辑器。 \"editor.formatOnSave\": true, //控制行高。使用 0 通过字号计算行高。 \"editor.lineHeight\": 25, //控制是否显示 minimap \"editor.minimap.enabled\": false, //在通过鼠标添加多个光标时使用的修改键。 \"editor.multiCursorModifier\": \"ctrlCmd\", //控制编辑器应如何呈现当前行突出显示，可能为“无”、“装订线”、“线”和“全部”。 \"editor.renderLineHighlight\": \"none\", //控制编辑器在空白字符上显示特殊符号的方式。 \"editor.renderWhitespace\": \"none\", //控制是否将代码段与其他建议一起显示以及它们的排序方式。 \"editor.snippetSuggestions\": \"top\", //一个制表符等于的空格数 \"editor.tabSize\": 2, //在未能恢复上一会话信息的情况下，控制启动时显示的编辑器。 \"workbench.startupEditor\": \"newUntitledFile\", /*窗口*/ //调整窗口的缩放级别。原始大小是 0，每次递增(例如 1)或递减(例如 -1)表示放大或缩小 20%。也可以输入小数以便以更精细的粒度调整缩放级别。 \"window.zoomLevel\": 2, /*文件*/ //配置语言的文件关联(如: \"*.extension\": \"html\")。这些关联的优先级高于已安装语言的默认关联。 \"files.associations\": &#123; \"_.vue\": \"vue\", \"_.wxss\": \"css\" &#125;, //配置 glob 模式以在搜索中排除文件和文件夹。例如，文件资源管理器根据此设置决定文件或文件夹的显示和隐藏。 \"files.exclude\": &#123; \"**/.idea\": true, \"**/yarn.lock\": true, \"**/tmp\": true &#125;, //保存裁剪空格 \"files.trimTrailingWhitespace\": true, /*搜索*/ //配置 glob 模式以在搜索中排除文件和文件夹。 \"search.exclude\": &#123; \"**/dist\": true, \"**/build\": true, \"**/elehukouben\": true, \"**/.git\": true, \"**/.gitignore\": true, \"**/.svn\": true, \"**/.DS_Store\": true, \"**/.idea\": true, \"**/.vscode\": false, \"**/yarn.lock\": true, \"**/tmp\": true &#125;, /*HTML*/ //配置内置 HTML 语言支持是否建议 Angular V1 标记和属性。 \"html.suggest.angular1\": false, //配置内置 HTML 语言支持是否建议 Ionic 标记、属性和值。 \"html.suggest.ionic\": false, /*TypeScript*/ //在 VS Code 中重命名或移动文件时启用或禁用自动更新 import 语句的路径。 \"javascript.updateImportsOnFileMove.enabled\": \"always\", /*集成终端*/ //控制终端的行高，此数字乘上终端字号得到实际行高(以像素为单位)。 \"terminal.integrated.lineHeight\": 1.8, /*ESLint*/ //文件保存时，是否自动根据 eslint 进行格式化 \"eslint.autoFixOnSave\": false, // 是否开启 eslint 检测 \"eslint.enable\": false, //eslint 能够识别的文件后缀类型 \"eslint.validate\": [ &#123; \"language\": \"html\", \"autoFix\": false &#125;, &#123; \"language\": \"javascript\", \"autoFix\": false &#125;, &#123; \"language\": \"javascriptreact\", \"autoFix\": false &#125;, &#123; \"language\": \"typescript\", \"autoFix\": false &#125;, &#123; \"language\": \"typescriptreact\", \"autoFix\": false &#125;, &#123; \"language\": \"vue\", \"autoFix\": false &#125; ], /*Gitlens Configuration*/ //细节,配置 gitlen 中 git 提交历史记录的信息显示情况 \"gitlens.advanced.messages\": &#123; \"suppressShowKeyBindingsNotice\": true, \"suppressUpdateNotice\": true &#125;, //开启 eslint 规则 // prettier 进行格式化时是否安装 eslint 配置去执行，建议 false \"prettier.eslintIntegration\": true, //如果为真，则将多行JSX元素的“&gt;”放在最后一行的末尾，而不是单独在下一行上。 \"prettier.jsxBracketSameLine\": true, //在该行限制中拟合代码 \"prettier.printWidth\": 200, //启用单引号 \"prettier.singleQuote\": true, /*代码同步配置*/ \"sync.askGistName\": false, \"sync.autoDownload\": false, \"sync.autoUpload\": false, \"sync.forceDownload\": false, \"sync.gist\": \"710bcbf7c3f171d47d3b23e2030d469e\", \"sync.quietSync\": false, \"sync.removeExtensions\": true, \"sync.syncExtensions\": true, \"sync.host\": \"\", \"sync.pathPrefix\": \"\", \"sync.lastUpload\": \"\", \"sync.lastDownload\": \"2018-08-17T02:21:37.318Z\", /*Git*/ //是否启用自动拉取 \"git.autofetch\": true, //在没有暂存的更改时提交所有更改。 \"git.enableSmartCommit\": true, /*Emmet*/ //在默认不支持 Emmet 的语言中启用 Emmet 缩写功能。 \"emmet.includeLanguages\": &#123; \"jsx-sublime-babel-tags\": \"javascriptreact\", \"javascript\": \"javascriptreact\" &#125;, //为指定的语法定义配置文件或使用带有特定规则的配置文件。 \"emmet.syntaxProfiles\": &#123; \"vue-html\": \"html\", \"vue\": \"html\", \"javascript\": \"javascriptreact\", // xml 类型文件默认都是单引号，开启对非单引号的 emmet 识别 \"xml\": &#123; \"attr_quotes\": \"single\" &#125; &#125;, //启用后，按下 TAB 键，将展开 Emmet 缩写。 \"emmet.triggerExpansionOnTab\": true, /*power效果插件*/ //是否启用power插件效果 \"powermode.enabled\": false, /*vetur插件*/ //设置vue文件js格式化 \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", //设置vue文件html格式化 \"vetur.format.defaultFormatter.html\": \"js-beautify-html\", /*插件Easy LESS*/ \"less.compile\": &#123; // true =&gt; 删除多余空白 \"compress\": true, // true =&gt; 生成源映射（.CS.MAP文件） \"sourceMap\": true, // false =&gt; 不要输出.CSS文件（每个文件可重写，见下文） \"out\": false &#125;, \"workbench.iconTheme\": \"vscode-icons\"&#125; 快捷键12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 将按键绑定配置放入此文件中即可覆盖默认值[ &#123; key: 'ctrl+f1', command: 'extension.openInBrowser' &#125;, &#123; key: 'alt+b', command: '-extension.openInBrowser' &#125;, &#123; key: 'alt+t', command: 'toggleFindInSelection', when: 'editorFocus' &#125;, &#123; key: 'alt+l', command: '-toggleFindInSelection', when: 'editorFocus' &#125;, /*方向键和选择提示键位*/ &#123; key: 'alt+j', command: 'cursorLeft', when: 'textInputFocus' &#125;, &#123; key: 'left', command: '-cursorLeft', when: 'textInputFocus' &#125;, &#123; key: 'alt+i', command: 'cursorUp', when: 'textInputFocus' &#125;, &#123; key: 'up', command: '-cursorUp', when: 'textInputFocus' &#125;, &#123; key: 'alt+k', command: 'cursorDown', when: 'textInputFocus' &#125;, &#123; key: 'down', command: '-cursorDown', when: 'textInputFocus' &#125;, &#123; key: 'alt+l', command: 'cursorRight', when: 'textInputFocus' &#125;, &#123; key: 'right', command: '-cursorRight', when: 'textInputFocus' &#125;, &#123; key: 'alt+i', command: 'selectPrevSuggestion', when: 'suggestWidgetMultipleSuggestions &amp;&amp; suggestWidgetVisible &amp;&amp; textInputFocus' &#125;, &#123; key: 'up', command: '-selectPrevSuggestion', when: 'suggestWidgetMultipleSuggestions &amp;&amp; suggestWidgetVisible &amp;&amp; textInputFocus' &#125;, &#123; key: 'alt+k', command: 'selectNextSuggestion', when: 'suggestWidgetMultipleSuggestions &amp;&amp; suggestWidgetVisible &amp;&amp; textInputFocus' &#125;, &#123; key: 'down', command: '-selectNextSuggestion', when: 'suggestWidgetMultipleSuggestions &amp;&amp; suggestWidgetVisible &amp;&amp; textInputFocus' &#125;]; 代码片段1234567891011121314151617181920212223242526272829303132&#123; \"head\": &#123; \"prefix\": \"head\", \"body\": [\"---\", \"title: '$1'\", \"category: $2\", \"tags: [$3]\", \"date: $4\", \"---\"], \"description\": \"快速输入博客头部\" &#125;, \"log\": &#123; \"prefix\": \"log\", \"body\": \"console.log($1)\" &#125;, \"warn\": &#123; \"prefix\": \"warn\", \"body\": \"console.warn($&#123;1:'后端返回数据问题'&#125;);\" &#125;, \"ims\": &#123; \"prefix\": \"ims\", \"body\": \"import $&#123;1:styles&#125; from '$&#123;2:./index.less&#125;';\" &#125;, \"dva\": &#123; \"prefix\": \"dva\", \"body\": \"import &#123; connect &#125; from 'dva';\" &#125;, \"dvac\": &#123; \"prefix\": \"dvac\", \"body\": [\"@connect((&#123; $&#123;1:sale&#125; &#125;) =&gt; (&#123;\", \" $&#123;2:sale&#125;,\", \"&#125;))\"] &#125;, \"menuSetting\": &#123; \"prefix\": \"menuSetting\", \"body\": [\"&#123;\", \" path: '$&#123;1:/dashboard&#125;',\", \" name: '$&#123;2:dashboard&#125;',\", \" icon: '$&#123;3:dashboard&#125;',\", \" routes: [$4],\", \"&#125;,\"], \"description\": \"菜单\" &#125;&#125;","tags":[{"name":"工具","slug":"工具","permalink":"https://shawdanon.github.io/tags/工具/"}]},{"title":"webpack总结","date":"2018-07-31T16:00:00.000Z","path":"2018/webpack/","text":"版本：4.16.3使用 webpack 所需要的包：webpack、webpack-cli（此工具用于在命令行中运行 webpack），webpack4 之后将 webpack-cli 从 webpack 中分离的出来。 webpack 基本配置webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const path = require('path'); //导入node.js的path模块const HtmlWebpackPlugin = require('html-webpack-plugin'); //导入自动生成HTML插件const CleanWebpackPlugin = require('clean-webpack-plugin'); //导入清理文件夹插件const config = &#123; /** *设置入口，用于设置打包的索引文件。 *单入口用字符串，多入口用对象。 */ entry: &#123; app: './src/index.js', print: './src/print.js' &#125;, /** *设置出口，用于设置打包的位置和文件名。 *filename表示打包后的文件名。 *[name]表示入口属性名。 *path表示打包后存放的路径。 *path.resolve表示获取绝对位置。 *__dirname表示当前执行脚本所在的目录。 */ output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, './dist') &#125;, /** *设置loader，用于对模块的源代码进行转换。 *用于在 import 或\"加载\"模块时预处理文件。 *loader对象放在module对象下的rules数组中。 *loader对象的test表示匹配什么文件。 *loader对象的use表示引用什么loader */ module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;, /** *设置插件，用于处理 *添加插件需要先导入再实例化。 */ plugins: [ new CleanWebpackPlugin(['dist']), //用于清理dist文件夹 new HtmlWebpackPlugin(&#123; title: 'Output Management' &#125;) //用于自动生成HTML ]&#125;; //定义配置文件module.exports = config; //导出配置文件 运行配置：npx webpack –config webpack.config.js在 package.js 中 script 设置，”build”:“webpack –config webpack.config.js”PS：–config webpack.config.js 用于设置运行文件名，不设置默认运行 webpack.config.js source mapwebpack.config.js 123456789101112131415161718const path = require('path');module.exports = &#123; entry: &#123; app: './src/index.js', print: './src/print.js' &#125;, output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125;, /** *用于追踪错误和警告在源代码中的原始位置。 *不设置：显示打包后的代码。（用于生产环境） *inline-source-map：显示原始源代码。 */ devtool: 'inline-source-map'&#125;; 模块热替换webpack 设置方法webpack.config.js 12345678910111213141516171819202122232425const path = require('path');const webpack = require('webpack');module.exports = &#123; entry: &#123; app: './src/index.js' &#125;, /** *设置webpack-dev-server，用于提供服务器。 *contentBase用于设置服务器目录。 *hot表示是否启用webpack的模块热替换特性。 */ devServer: &#123; contentBase: './dist', hot: true &#125;, plugins: [ new webpack.NamedModulesPlugin(), //当开启HMR的时候使用该插件会显示模块的相对路径。 new webpack.HotModuleReplacementPlugin() //模块热替换插件。 ], output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; 运行配置：npx webpack-dev-server –open –config webpack.config.js在 package.js 中 script 设置，”start”:“webpack-dev-server –open –config webpack.config.js”PS：–config webpack.config.js 用于设置运行文件名，不设置默认运行 webpack.config.js node 设置方法dev-server.js 1234567891011121314151617const webpackDevServer = require('webpack-dev-server');const webpack = require('webpack');const config = require('./webpack.config.js');const options = &#123; contentBase: './dist', hot: true, host: 'localhost'&#125;;webpackDevServer.addDevServerEntrypoints(config, options);const compiler = webpack(config);const server = new webpackDevServer(compiler, options);server.listen(5000, 'localhost', () =&gt; &#123; console.log('dev server listening on port 5000');&#125;); 运行配置：node dev-server.js在 package.js 中 script 设置，”start”:“node dev-server.js”","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"}]},{"title":"Node.js","date":"2018-01-23T16:00:00.000Z","path":"2018/node/","text":"安装（Windows）先到官网下载 msi 安装包,建议下载 LTS（长期支持）版本。如图 1： 图1 双击安装包，如图 2： 图2 点击 next，如图 3： 图3 勾选同意协议，点击 next，如图 4： 图4 选择安装路径，点击 next，如图 5： 图5 点击 next，如图 6： 图6 点击 install，如图 7： 图7 安装完成后，如图 8： 图8 为了验证是否安装成功，需要运行命令行来确认，使用 Windows+R 键打开运行界面，如图 9： 图9 输入 cmd，点击确定，出现命令行窗口，输入node -v出现版本号表示 node 安装成功，npm -v出现版本号表示 npm 安装成功。 图10 PS：由于 npm 的镜像源在国外，所以国内使用下载很慢，建议使用国内镜像安装快，操作步骤如下：1、临时使用打开命令行，输入npm --registry https://registry.npm.taobao.org install package，package 为需要安装的包名。2、持久使用打开命令行，输入npm config set registry https://registry.npm.taobao.org，更换 npm 镜像地址。可以通过输入命令npm config get registry来验证是否配置成功。成功如图 11： 图11 3、通过 cnpm 使用打开命令行，输入npm install -g cnpm --registry=https://registry.npm.taobao.org，安装完成后通过命令cnpm install package安装包，package 为需要安装的包名。","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"}]},{"title":"vue-cli环境搭建","date":"2018-01-23T16:00:00.000Z","path":"2018/vue-cli/","text":"vue-cli 环境搭建。 安装 node因为需要 npm 来装 vue-cli，所以需要先装 node，没有装的同学移步node进行安装。 安装 vue打开命令行输入npm install -g vue-cli 搭建 vue-cli 脚手架打开命令行输入vue init webpack vue-testvue-cli 的配置信息：Project name (vue-test)项目名称，可以自己指定，也可直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错 Sorry, name can no longer contain capital letters）。Project description (A Vue.js project)项目描述，也可直接点击回车，使用默认名字。Author 作者，同上。Vue build（Use arrow keys)1、Runtime + Compiler: recommended for most users运行+编译，推荐给大多数用户，点击回车选择。2、Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere仅运行时，已经选择第一个了。Install vue-router? (Y/n)是否安装 vue-router，这是官方的路由，大多数情况下都使用。这里就输入“y”后回车即可。Use ESLint to lint your code? (Y/n)是否使用 ESLint 管理代码，ESLint 是个代码风格管理工具，是用来统一代码风格的，并不会影响整体的运行，这也是为了多人协作，新手就不用了，一般项目中都会使用。ESLint 官网，这里就输入“y””n”都可以。Pick an ESLint preset (Use arrow keys)选择一个 ESLint 预设，编写 vue 项目时的代码风格，因为我选择了使用 ESLint。1、Standard标准，有些看不明白，什么标准呢，去给提示的 standardgithub 地址看一下， 原来时 js 的标准风格。2、AirBNBJavaScript 最合理的方法，这个 github 地址说的是 JavaScript 最合理的方法。3、none (configure it yourself)不选择。 Set up unit tests? (Y/n)是否安装单元测试，我选择安装。Pick a test runner? (Use arrow keys)选择自动化测试工具。1、JestFacebook 开发的一个对 javascript 进行单元测试的工具。2、karma and Mocha常用的自动化测试工具，我选它。3、none(configure it yourself)不选择。Setup e2e tests with Nightwatch(Y/n)?是否安装 e2e 测试 ，我选择安装。Should we run npm install for you after the project has been created? (recommended) (Use arrow keys)选择用什么安装依赖包。1、Yes, use NPM选择 npm 安装。2、Yes, use Yarn选择 yarn 安装。3、No, I will handle that myself暂时安装，自行安装。我选择这个。基本框架搭建完成，进入 vue-test 目录，打开命令行，输入npm install开始安装所需要的依赖包。装完后（所有依赖正常安装），输入命令npm run dev开始运行示例页面。默认访问 127.0.0.1:8080。示例如图 1： 图1 下面来看看项目目录： 123456789101112131415161718192021222324252627├── build/ # webpack配置参数文件│ └── ...├── config/│ ├── index.js # 主项目的配置│ └── ...├── src/│ ├── main.js # 应用入口│ ├── App.vue # 主应用组件│ ├── router/ # 路由│ │ └── index.js # 路由配置文件│ ├── components/ # UI组件│ │ └── ...│ └── assets/ # 模块资源（webpack提供）│ └── ...├── static/ # 纯静态资源（打包时直接复制）├── test/│ └── unit/ # 单元测试│ └── e2e/ # e2e tests测试├── .babelrc # babel编译参数├── .editorconfig # 编辑器配置├── .eslintignore├── .eslintrc.js # eslint配置文件，用以规范团队开发编码规范├── .gitignore # github提交文件屏蔽的配置文件├── .postcssrc.js├── index.html # 主页模板├── package.json # 项目文件，记载着一些命令和依赖还有简要的项目描述信息└── README.md","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"}]},{"title":"Tomcat安装","date":"2018-01-04T16:00:00.000Z","path":"2018/Tomcat/","text":"下载 Tomcat进入Tomcat 官网，下载对应你 jdk 版本的 Tomcat。 配置环境变量在系统环境变量中配置名字为 JAVA_HOME 路径为你的 jdk 路径，名字为 CATALINA_HOME 路径为你的 Tomcat 路径。如下示例： 12JAVA_HOME=C:\\Program Files (x86)\\Java\\jdk1.7.0_71CATALINA_HOME=C:\\Program Files (x86)\\Java\\apache-tomcat-7.0.82 安装解压 Tomcat 安装包即可 使用将项目放置 webapps 目录里，在 bin 目录中运行 startup.bat 文件启动 Tomcat 服务器。运行 shutdown.bat 文件停止服务器。","tags":[{"name":"服务器","slug":"服务器","permalink":"https://shawdanon.github.io/tags/服务器/"}]},{"title":"初探manjaor","date":"2018-01-01T16:00:00.000Z","path":"2018/first-manjaor/","text":"第一次使用 manjaor… 写在前面在distrowatch中发行版排行第一的 Linux,兼顾性能和易用的版本,抱着这样的心情我开始使用它.首先下载的官方推荐的 XFCE 版,不习惯这个桌面,之后下载了社区版的 Deepin 桌面.桌面选好就开始装软件,刚开始搜索到的都是通过命令pacman安装,配置许久就是不成功,说好的易用呢?就这样折腾了几次.趁着国庆假期长,再来折腾一下,让我找到了 manjaor 的正确使用姿势. 安装中文输入法1 打开软件包管理器2 搜索 fcitx-im 会出现六个包(fcitx 配置|fcitx|fcitx-gtk2|fcitx-gtk3|fcitx-qt4|fcitx-qt5),勾起全部,点击应用即可安装.3 搜索 fcitx-configtool 会出现三个包(fcitx 配置|fcitx|fcitx-configtool),由于前两个装过了,只需要装第三包即可.4 搜索 fcitx 可以看到很多包,我们装一个谷歌拼音 fcitx-googlepinyin.5 配置.xprofile 文件,在~目录中找到.xprofile 文件,没有的话就创建一个,文件中写入以下内容并保存,然后重启就可以使用中文输入法了. 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=\"@im=fcitx","tags":[{"name":"数据库","slug":"数据库","permalink":"https://shawdanon.github.io/tags/数据库/"}]},{"title":"MySQL安装","date":"2018-01-01T16:00:00.000Z","path":"2018/mySQL/","text":"mysql 安装总结… 下载 MySQL打开MySQL 社区版官方下载下载 Windows (x86, 32-bit/64-bit), ZIP Archive 安装包。32 位 64 位根据电脑选。我目前的版本是 5.7.20。 配置 MySQL下载并复制到 mysql 里的 bin 目录下。解压安装包，在安装包目录创建一个 data 空文件夹和创建一个 my.ini 文件，文件内容如下。 12345678910111213141516171819202122232425262728293031[mysql]; 设置mysql客户端默认字符集default-character-set=utf8[mysqld];设置3306端口port = 3306; 设置mysql的安装目录(需要改动成你的目录)basedir=C:\\Users\\Administrator\\Desktop\\java\\mysql-5.7.20-winx64; 设置mysql数据库的数据的存放目录(需要改动成你的目录)datadir=C:\\Users\\Administrator\\Desktop\\java\\mysql-5.7.20-winx64\\data; 允许最大连接数max_connections=200; 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8; 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 1、安装 MySQL 服务打开命令行，进入 MySQL 的 bin 目录。2、安装 Windows 服务输入mysqld install，出现The service already exists则安装成功。3、初始化 data 目录输入mysqld --initialize-insecure --user=mysql，不报错则初始化成功。PS:使用-initialize 生成随机密码，使用-initialize-insecure 生成空密码。默认帐号 root,后面的-user=mysql 不更改4、启动 MySQL 服务输入net start mysql，出现MySQL 服务启动成功则启动服务成功。 配置环境变量1、打开环境变量设置：在我的电脑上右键-&gt;点击属性-&gt;点击高级系统设置-&gt;点击环境变量复制你 mysql 文件路径，在系统变量里找到 Path 变量，点击编辑，光标移动到最前面，粘贴，加上;即可。 登录 MySQL打开命令行。输入mysql -uroot -p，输入密码，出现mysql&gt;则成功登录。 修改密码（忘记密码）my.ini 配置文件[mysqld]条目下加一条命令 skip-grant-tables,然后重启 mysql 服务。1、进入 MySQL 数据库：打开命令行。输入mysql -uroot -p，出现mysql&gt;则成功进入。2、准备修改密码：输入mysql&gt; use mysql;，出现Database changed则准备成功。3、给 root 用户重置密码：输入mysql&gt; update user set authentication_string=password(&quot;新密码&quot;) where user=&quot;root&quot;;，出现Query OK,1 rows affected(0.01sec)Rows matched:1 Changed:1Warnings: 0则修改成功。4、刷新数据库：输入mysql&gt; flush privileges;，出现QueryOK, 0 rows affected (0.00 sec)则刷新成功。5、退出数据库：输入mysql&gt; quit退出数据库。注释掉 my.ini 里的 skip-grant-tables。完成上面 5 步则成功修改密码。","tags":[{"name":"数据库","slug":"数据库","permalink":"https://shawdanon.github.io/tags/数据库/"}]},{"title":"2017总结","date":"2017-12-30T16:00:00.000Z","path":"2017/summary/","text":"总结 2017，希望 2018 加油… 今天是 2017 的最后一天，已经毕业一年半了。大事件：1、换了工作，从外包公司到了研发公司。今年收获：1、喜欢上了阅读，并养成了阅读的习惯。2、写博客次数变多了，在写作过程中加强了表达能力。3、坚持使用 github，并有一个项目超过 10 颗星。4、巩固了 Web 开发基础：闭包、原型链、http 请求等。粗略学习了 react、node.js、npm、ECharts。了解了 webpack、gulp、grount、ES6、typescript。5、熟悉了前后端通过 ajax 协作开发。明年愿景：1、坚持阅读、写作、运动。2、学习更多知识，构建自己的知识体系。3、到处走走看看，体验不同地域的文化。","tags":[{"name":"总结","slug":"总结","permalink":"https://shawdanon.github.io/tags/总结/"}]},{"title":"git安装","date":"2017-12-17T16:00:00.000Z","path":"2017/git-install/","text":"git 安装… windwos 版打开git 官网下载最新版的 git，如下图 git下载示例 下载完成后一直点下一步即可完成安装。","tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://shawdanon.github.io/tags/版本控制/"}]},{"title":"搬入hexo","date":"2017-12-12T16:00:00.000Z","path":"2017/move-hexo/","text":"由于用 node 比较多，所以想试试基于 node 的 hexo… 准备搭建 hexo 前需要先装 node。打开Node.js 官网下载 LTS 版本即可。Windows 安装直接双击 msi 文件，一直下一步即可完成安装。 安装 hexo打开命令行，输入npm install hexo-cli -g。 建立你的博客打开命令行，输入hexo init blog。然后就会在当前目录创建一个名为 blog 的文件夹，这个就是你的博客文件了。 运行你的博客进入你的博客目录，打开命令行，输入hexo server。你就可以在http://127.0.0.1:4000/访问你的博客了。 GitHub 部署博客新建仓库打开_config.yml,进行基础配置 123deploy: type: git repo: https://github.com/...... 仓库地址 安装 hexo-deployer-git 自动部署发布工具 1npm install hexo-deployer-git --save 发布到 Github 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://shawdanon.github.io/tags/博客搭建/"}]},{"title":"npm常用命令","date":"2017-12-11T16:00:00.000Z","path":"2017/npm/","text":"npm 常用命令… 常用命令npm install 安装模块安装模块分全局安装和本地安装。全局安装是安装在 npm 默认目录，在这个电脑上的项目都可以使用全局安装的模块；本地安装是将模块安装在当前目录中，这些模块只能供当前目录的项目使用。本地安装模块（moduleName 是模块名字）： 1npm install moduleName 全局安装模块（moduleName 是模块名字）： 1npm install -g moduleName npm uninstall 卸载模块卸载模块（moduleName 是模块名字）： 1npm uninstall moduleName npm update 更新模块更新模块（moduleName 是模块名字）： 1npm update moduleName npm ls 查看安装的模块1npm ls 1npm ls --depth=0 //查看模块的第一个文件夹名","tags":[{"name":"包管理器","slug":"包管理器","permalink":"https://shawdanon.github.io/tags/包管理器/"}]},{"title":"前端问题","date":"2017-09-21T16:00:00.000Z","path":"arrangement/front-end-problem/","text":"前端遇到的一些问题汇总… JavaScript跨页面传值问题一、地址栏传值方式原理是把参数放入跳转页面的 url 里，跳转页面后读取当前页面的 url 就可以获得上一个页面传过来的参数。下面代码是通过 JS 跳转到 www.tangxiaoping.top/search 页面，传入?a=1&amp;b=1字符串。通常我们使用?来隔断 url 和需要传入的字符串，用&amp;隔断不同的参数，用=隔断参数和参数对应的值。 1window.location.href = 'https://www.tangxiaoping.top/search?a=1&amp;b=1'; 那么跳转完页面我们就需要获取我们需要的参数了。通过下面的方法获得带有参数的对象，通过对象获取我们需要的值。 123456789101112var obj = parseURL(location.href); //调用解析url方法，传入参数为url，将返回值赋值给objfunction parseURL(url) &#123; var str = url.split('?')[1]; //获取?后面的字符串 var strArr = str.split('&amp;'); //通过&amp;符号把str分割成字符串数组 var obj = &#123;&#125;; //定义一个对象 var arr = []; //定义一个数组 for (var i = 0; i &lt; strArr.length; i++) &#123; arr = strArr[i].split('='); //通过=符号把strArr分割成字符串数组 obj[arr[0]] = arr[1]; //把=左边的字符串设为obj属性，把=右边的字符串设为值 &#125; //将strArr遍历一遍 return obj; //返回一个对象（包括我们需要的参数和值）&#125; //解析url的方法 二、session三、Cookies四、Application在 js 中引入其他 js使用场景：多个页面需要引入多个相同的 js 时、多个页面引入 js 的 src 需要频繁更改时一、如下代码所示，在公共 js 中使用 document.write 来同步引入其他 js。index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"common.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; common.js 1document.write(\"&lt;script src=''&gt;&lt;/script&gt;\"); //src自行填写 二、如下代码所示，通过 appendChild 异步引入其他 js 123var js = document.createElement('script'); //创建标签元素js.src = ''; //给标签src赋值，src自行填写document.head.appendChild(js); //将标签动态加入head里 ready()用法当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。由于该事件在文档就绪后发生，因此把所有其他的 jQuery 事件和函数置于该事件中是非常好的做法。正如上面的例子中那样。ready() 函数规定当 ready 事件发生时执行的代码。ready() 函数仅能用于当前文档，因此无需选择器。允许使用以下三种语法：语法 1 1$(document).ready(function) 语法 2 1$().ready(function) 语法 3 1$(function) JavaScript 刷新页面location.reload() 工具NPM 报错：Unexpected end of JSON input while parsing near ‘…”:”0.5.x”,”raw-loader’清楚缓存：npm cache clean –force","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"},{"name":"整理","slug":"整理","permalink":"https://shawdanon.github.io/tags/整理/"}]},{"title":"jekyll","date":"2017-09-11T16:00:00.000Z","path":"2017/jekyll-build/","text":"jekyll 使用总结… 第二次搭建 jekyll 了，结果还是出错了些，不过也比第一次快了很多，还是记录一下吧。 安装1、下载 ruby(本次用的rubyinstaller-2.4.1-2-x64);2、安装 ruby 会有三个选项： Add Ruby executables to your PATH Associate .rb and .rbw files with this Ruby installation Use UTF-8 as default external encoding 都选上钩，接着下一步完成安装，打开命令行窗口输入ruby -v若看到ruby 2.4.1p111 (2017-03-22 revision 58053) [x64-mingw32]则表示安装成功。 搭建1、打开命令行窗口，输入gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/把国外镜像换成国内镜像，这样做可以使安装软件速度加快。2、打开命令行窗口，输入gem install bundler安装依赖包 bundler，然后输入gem install jekyll安装 jekyll。3、打开命令行窗口，输入jekyll new 123创建一个 jekyll 默认博客名字叫 123，如果有博客也需要创建一次，防止报错。4、进入 123 文件目录（你的 jekyll 博客），打开命令行窗口（shift+鼠标右键，点击‘在此处打开命令窗口’），输入jekyll serve，看到Server address: http://127.0.0.1:4000/ Server running... press ctrl-c to stop.然后就可以在服务器上浏览了,浏览地址：http://127.0.0.1:4000/。","tags":[{"name":"博客","slug":"博客","permalink":"https://shawdanon.github.io/tags/博客/"},{"name":"框架","slug":"框架","permalink":"https://shawdanon.github.io/tags/框架/"}]},{"title":"判断IE版本的HTML语句","date":"2017-08-13T16:00:00.000Z","path":"2017/something-of-ie/","text":"IE那些事… 经常用一些框架会看到类似注释一样的语句，例如bootstrap里的： 1234&lt;!--[if lt IE 9]&gt; &lt;script src=\"https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 写了这个代码就能兼容IE8了。那么这些代码是什么意思呢？我们来看下面例子： 12345678910&lt;!--[if !IE]&gt;除IE外都可识别 &lt;![endif]--&gt;&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt; 语句 例子 说明 ! [if !IE] NOT运算符。这是摆立即在前面的功能，操作员，或子表达式扭转布尔表达式的意义。 lt [if lt IE 5.5] 小于运算符。如果第一个参数小于第二个参数，则返回true。 lte [if lte IE 6] 小于或等于运算。如果第一个参数是小于或等于第二个参数，则返回true。 gt [if gt IE 5] 大于运算符。如果第一个参数大于第二个参数，则返回true。 gte [if gte IE 7] 大于或等于运算。如果第一个参数是大于或等于第二个参数，则返回true。 () [if !(IE 7)] 子表达式运营商。在与布尔运算符用于创建更复杂的表达式。 &amp; [if (gt IE 5)&amp;(lt IE 7)] AND运算符。如果所有的子表达式计算结果为true，返回true &#124; [if (IE 6)&#124;(IE 7)] OR运算符。返回true，如果子表达式计算结果为true。","tags":[{"name":"前端","slug":"前端","permalink":"https://shawdanon.github.io/tags/前端/"}]},{"title":"搬入jekyll","date":"2017-08-08T16:00:00.000Z","path":"2017/move-into-jekyll/","text":"换博客… 原来的博客引擎WordPress 现在的博客引擎jekyll 起因由于 WordPress 太笨重，每次写文章很麻烦，所以也不怎么去用它。后来在 github 上看到 jekyll，感觉很适合我，而且节省了服务器的费用。 过程折腾了一两个月，断断续续的学习了 jekyll，对比了 hexo，最终还是选择了 jekyll。 结果在网上看了很多 jekyll 的主题，也有不少我喜欢的主题，最终我还是没有用它们。我选择从头开始，自己写一个适合自己的主题。 今天开始我的 jekyll！","tags":[{"name":"说说","slug":"说说","permalink":"https://shawdanon.github.io/tags/说说/"}]},{"title":"阅读","date":"2017-05-06T16:00:00.000Z","path":"2017/read/","text":"阅读《前端工程师的自我修养》感触… 刚读完，《前端工程师的自我修养》，感触颇深。 我还记得我第一次阅读是在小学时期，书籍是《淘气包马小跳》，当时应该还是很喜欢看的。 初中是开启我阅读的篇章，我记忆深刻的是《诛仙》。这是一本仙侠类小说，其中古风的文字描述、山海经的奇珍异兽、曲折的故事情节深深吸引了我。因为这本小说我开始对古风文学产生兴趣，因为这本小说我开始理解“善非善，恶非恶”，“鬼厉”之名也因此而来。 高中开始也一度为文学痴迷，读了些王小波、韩寒的小说。 大学就很少看书了，大多数信息获取都来自互联网。 如今又对读书产生了兴趣，感到好像发现了一片新的世界一样……","tags":[{"name":"说说","slug":"说说","permalink":"https://shawdanon.github.io/tags/说说/"}]},{"title":"程序员常用的网站","date":"2016-09-17T16:00:00.000Z","path":"arrangement/used-website/","text":"一些常用网站记录… 程序员通用GitHub：一个面向开源及私有软件项目的托管平台。stackoverflow：一个与程序相关的 IT 技术问答网站。CSDN：中国最大的 IT 社区和服务平台。 关于 web 开发者常用的网站（That’s me）npm：一个 NodeJS 包管理和分发工具，已经成为了非官方的发布 Node 模块（包）的标准。bootstrap：来自 Twitter，目前很受欢迎的前端框架。W3School：因特网上最大的 WEB 开发者资源。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://shawdanon.github.io/tags/笔记/"},{"name":"整理","slug":"整理","permalink":"https://shawdanon.github.io/tags/整理/"}]},{"title":"大学回忆录","date":"2016-07-02T16:00:00.000Z","path":"2016/university-memoirs/","text":"我的大学生涯总结… 我的大学生活就这么结束了，现在想想感觉也挺充实的。三年时光，匆匆而逝，其实承载着满满的回忆。 大一上期： 学习：程序设计基础：C 语言（VC、VS2012）、计算机组装、计算机导论 项目：学生管理系统 经历：由于高中流程图学得好加上有点 Pascal 基础，专业学得很轻松。大部分时间花在了社团上面，加入了校学生会.权益部、系学生会.CSC（原办公自动化服务队）、协会.计算机协会、图书馆.图书管理委员会，结交了不少朋友，印象比较深的是权益部师兄师姐们分享经验（虽然具体什么经验记不清了），还有在 CSC 和计算机协会 get 了很多系统维护类资源。在数码广场兼职推销电脑，好像还赚了不少钱，不过感觉有欺骗性质第二期就没干了。 大一下期 学习：Photoshop、网页制作技术、数据结构、办公自动化、flash、面向对象程序设计 项目：数据结构迷宫小程序（VC）、欢送视频、迎新视频 经历：完全沉迷进了 Adobe 套件（PS、Pr、AE）、3dMax 和网页设计，在选修课认识了图书馆老师也学了不少网页布局知识，戴氏教育主页模仿巩固了 div+css 布局思想，各种海报传单设计，视频剪辑制作提升了我的设计水平。正好兼职认识的朋友自己开公司，帮忙设计名片和宣传单赚到第一笔技术费用。 大二上期 学习：C#语言程序设计、数据库原理（SQL Server）、Java 高级程序设计、计算机网络技术、电子商务应用及营销 项目：通讯录程序（C#）、仙剑类游戏官网、拓扑网络构建模型 经历：接触的第一个可视化编程语言，对这个特别感兴趣，自己还做了记事本、播放器、抽奖小程序，再次做网站提高了对 HTML 整体结构的了解。社团方面花的时间也比较多，毕竟担任计算机协会会长，系学生会 CSC 部长，图书管理委员会会长。俗话说的好，新官上任三把火，我也不列外，两眼一抹黑的我先从制度规则起手，参照过前几届的也收集过网上的制度资料，甚至了解过公司管理的一些资料，总算是拟定了方案。在这短短一学期内想了办了不少活动，提高了管理能力和沟通能力。 大二下期 学习：操作系统、大型数据库(Oracle) 、计算机系统与维护、Web 编程技术（ASP.NET）、商业沟通、软件工程、IT 产品及营销 项目：读书节大数据统计视频、教育网站（明智英才）、oracle 图书信息管理系统设计、数据库原理专周 经历：学习了基于 ASP.NET 的动态网站搭建方法，还有数据库设计，提升了我数据库的知识。社团合作让我接触到了社会的人，学会了通过共赢的方式促进双方合作。另外还接到了第一个商务网站建设项目，教育类。真真切切感受到了线上搭建网站的流程，免费获得了 2 年空间一个。 大三上期 学习：移动编程技术、Java EE 技术及应用 项目：新闻管理网站（C#+ASP.NET+SQL sever）、雷霆战机小游戏（C#）、kamila 网站 经历：实践了动态网站搭建，提高了数据库交互方面的知识，实践了雷霆战机小游戏，提高了面向对象编程思想。Kamila 网站，又是一个接到的项目，这个项目运用了 bootrap，然后也补了写 JavaScript 知识，总体提高很多。 大三下期 学习：实习 项目：毕业设计:赛事评分系统（C#+ASP.NET+SQL sever）、各类企业网站 经历：在外包公司实习，学的多的算是 cms 了，怎么高速建站成了我的必修课。这次赛事评分系统的复杂程度提升了我后端知识，也让我正在踏入全栈的门槛。 这么一一列出来发现真的还是经历了不少事情，现在回首真还有点别样的感觉。我觉得我是幸运的，能在大学遇到了两个科任老师：Mr.张、Miss.王，还有图书馆的老师们，让我在大学学到了不少东西；能有一起共事的社团朋友们，让我大学更加丰富多彩。","tags":[{"name":"总结","slug":"总结","permalink":"https://shawdanon.github.io/tags/总结/"}]},{"title":"建博之初","date":"2016-04-21T16:00:00.000Z","path":"2016/Initial-heart/","text":"兴致勃勃的建立博客… hello world！这个词语想必程序员都很熟悉，但是有多少人真正懂得这个词语的含义呢？我想今天我是明白了，那是内心的呼喊，那是对知识的渴望，那是对这个世界的敬畏，打出这两个单词真正让你心涌澎湃。 今天建立这个博客希望能够归纳知识，形成自己的知识体系。","tags":[{"name":"说说","slug":"说说","permalink":"https://shawdanon.github.io/tags/说说/"}]}]